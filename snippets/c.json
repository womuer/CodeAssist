{
    "for": {
        "prefix": "for",
        "body": [
            "for (${size_t} ${i} = ${1:0}; ${i} < ${2:length}; ${i}++)",
            "{",
			"	$3",
            "}"
        ],
        "description": "Code snippet for 'for' loop"
    },
    "forr": {
        "prefix": "forr",
        "body": [
            "for (int ${i} = ${1:length} - 1; ${i} >= ${2:0}; ${i}--)",
            "{",
			"	$3",
            "}"
        ],
        "description": "Code snippet for reverse 'for' loop"
    },
    "while": {
        "prefix": "while",
        "body": [
            "while ($1)",
            "{",
			"	$2",
            "}"
        ],
        "description": ""
    },
    "if": {
        "prefix": "if",
        "body": [
            "if ($1)",
            "{",
			"	$2",
            "}"
        ],
        "description": "Code snippet for if statement"
    },
    "else": {
        "prefix": "else",
        "body": [
            "else",
            "{",
			"	$1",
            "}"
        ],
        "description": "Code snippet for else statement"
    },
    "else if": {
        "prefix": "else if",
        "body": [
            "else if ($1)",
            "{",
			"	$2",
            "}"
        ],
        "description": "Code snippet for else-if statement"
    },
    "enum": {
        "prefix": "enum",
        "body": [
            "enum ${MyEnum}",
            "{",
			"	$1",
            "};"
        ],
        "description": "Code snippet for enum"
    },
    "#ifdef": {
        "prefix": "#ifdef",
        "body": [
            "#ifdef ${DEBUG}",
            "$1",
            "#endif // ${DEBUG}"
        ],
        "description": "Code snippet for #ifdef"
    },
    "#ifndef": {
        "prefix": "#ifndef",
        "body": [
            "#ifndef ${1:1}",
            "$2",
            "#endif // !$1"
        ],
        "description": "Code snippet for #ifndef"
    },
    "#if": {
        "prefix": "#if",
        "body": [
            "#ifdef ${1:0}",
            "$2",
            "#endif // $1"
        ],
        "description": "Code snippet for #if"
    },
    "struct": {
        "prefix": "struct",
        "body": [
            "struct ${MyStruct}",
            "{",
			"	$1",
            "};"
        ],
        "description": "Code snippet for struct"
    },
    "switch": {
        "prefix": "switch",
        "body": [
            "switch (${switch_on})",
            "{",
            "default:",
			"	break;$1",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "union": {
        "prefix": "union",
        "body": [
            "union ${MyUnion}",
            "{",
			"	$1",
            "};"
        ],
        "description": "Code snippet for union"
    },
    "#inc": {
        "prefix": "#inc",
        "body": [
            "#include \"$1\""
        ],
        "description": "Code snippet for #include \" \""
    },
    "#inc<": {
        "prefix": "#inc<",
        "body": [
            "#include <$1>"
        ],
        "description": "Code snippet for #include \" \""
    },
    "#def": {
        "prefix": "#def",
        "body": [
            "#define \"$1\" \"$2\" "
        ],
        "description": "Code snippet for #define \" \""
    },
    "#def": {
        "prefix": "#def",
        "body": [
            "#define \"$1\" \"$2\" "
        ],
        "description": "Code snippet for #define \" \""
    },
    "bubblesort": {
        "prefix": "arrBubblesort",
        "body": [
            "// 冒泡排序函数",
            "void bubbleSort(int arr[], int n) {",
            "    int temp;",
            "    int swapped;",
            "",
            "    for (int i = 0; i < n - 1; i++) {",
            "        swapped = 0; // 用于标记是否发生了交换",
            "",
            "        for (int j = 0; j < n - i - 1; j++) {",
            "            if (arr[j] > arr[j + 1]) {",
            "                // 交换arr[j]和arr[j+1]的位置",
            "                temp = arr[j];",
            "                arr[j] = arr[j + 1];",
            "                arr[j + 1] = temp;",
            "                swapped = 1; // 标记已发生交换",
            "            }",
            "        }",
            "",
            "        // 如果在本轮没有发生交换，说明数组已经有序，可以提前退出",
            "        if (swapped == 0) {",
            "            break;",
            "        }",
            "    }",
            "}"
        ],
        "description": "Code snippet forbubblesort \" \""
    },
    "bubblesort_cn": {
        "prefix": "数组冒泡排序",
        "body": [
            "// 冒泡排序函数",
            "void bubbleSort(int arr[], int n) {",
            "    int temp;",
            "    int swapped;",
            "",
            "    for (int i = 0; i < n - 1; i++) {",
            "        swapped = 0; // 用于标记是否发生了交换",
            "",
            "        for (int j = 0; j < n - i - 1; j++) {",
            "            if (arr[j] > arr[j + 1]) {",
            "                // 交换arr[j]和arr[j+1]的位置",
            "                temp = arr[j];",
            "                arr[j] = arr[j + 1];",
            "                arr[j + 1] = temp;",
            "                swapped = 1; // 标记已发生交换",
            "            }",
            "        }",
            "",
            "        // 如果在本轮没有发生交换，说明数组已经有序，可以提前退出",
            "        if (swapped == 0) {",
            "            break;",
            "        }",
            "    }",
            "}"
        ],
        "description": "Code snippet forbubblesort \" \""
    },
    "find_min_arr": {
        "prefix": "arrFindminarr",
        "body": [
            "int findMin(int arr[], int n) {",
            "    if (n <= 0) {",
            "        // 处理无效输入",
            "        printf(error);",
            "        return -1; // 返回一个标志值表示错误",
            "    }",
            "",
            "    int min = arr[0]; // 假定第一个元素为最小值",
            "",
            "    // 遍历数组，比较找到最小值",
            "    for (int i = 1; i < n; i++) {",
            "        if (arr[i] < min) {",
            "            min = arr[i]; // 更新最小值",
            "        }",
            "    }",
            "",
            "    return min;",
            "}"
        ],
        "description": "Code snippet for findminarr"
    },
    "find_min_arr_cn": {
        "prefix": "数组查找数组最小值",
        "body": [
            "int findMin(int arr[], int n) {",
            "    if (n <= 0) {",
            "        // 处理无效输入",
            "        printf(error);",
            "        return -1; // 返回一个标志值表示错误",
            "    }",
            "",
            "    int min = arr[0]; // 假定第一个元素为最小值",
            "",
            "    // 遍历数组，比较找到最小值",
            "    for (int i = 1; i < n; i++) {",
            "        if (arr[i] < min) {",
            "            min = arr[i]; // 更新最小值",
            "        }",
            "    }",
            "",
            "    return min;",
            "}"
        ],
        "description": "Code snippet for 查找数组最小值"
    },
    "selectionSort": {
        "prefix": "arrSelectionSort",
        "body": [
            "// 选择排序函数",
            "void selectionSort(int arr[], int n) {",
            "    int i, j, minIndex, temp;",
            "    ",
            "    for (i = 0; i < n - 1; i++) {",
            "        minIndex = i; // 假定未排序部分的第一个元素是最小的",
            "        for (j = i + 1; j < n; j++) {",
            "            // 寻找未排序部分中的最小元素的索引",
            "            if (arr[j] < arr[minIndex]) {",
            "                minIndex = j;",
            "            }",
            "        }",
            "",
            "        // 交换未排序部分的第一个元素和最小元素",
            "        temp = arr[i];",
            "        arr[i] = arr[minIndex];",
            "        arr[minIndex] = temp;",
            "    }",
            "}"
        ],
        "description": "Code snippet for selectionSort"
    },
    "selectionSortCn": {
        "prefix": "数组选择排序",
        "body": [
            "// 选择排序函数",
            "void selectionSort(int arr[], int n) {",
            "    int i, j, minIndex, temp;",
            "    ",
            "    for (i = 0; i < n - 1; i++) {",
            "        minIndex = i; // 假定未排序部分的第一个元素是最小的",
            "        for (j = i + 1; j < n; j++) {",
            "            // 寻找未排序部分中的最小元素的索引",
            "            if (arr[j] < arr[minIndex]) {",
            "                minIndex = j;",
            "            }",
            "        }",
            "",
            "        // 交换未排序部分的第一个元素和最小元素",
            "        temp = arr[i];",
            "        arr[i] = arr[minIndex];",
            "        arr[minIndex] = temp;",
            "    }",
            "}"
        ],
        "description": "Code snippet for selectionSort"
    },
    "quickSort": {
        "prefix": "arrQuickSort",
        "body": [
            "// 交换数组中两个元素的值",
            "void swap(int *a, int *b) {",
            "    int temp = *a;",
            "    *a = *b;",
            "    *b = temp;",
            "}",
            "",
            "// 分割数组，并返回分割点的索引",
            "int partition(int arr[], int low, int high) {",
            "    int pivot = arr[high]; // 选择最后一个元素作为枢纽元素",
            "    int i = low - 1; // 初始化较小元素的索引",
            "",
            "    for (int j = low; j <= high - 1; j++) {",
            "        if (arr[j] <= pivot) {",
            "            i++; // 较小元素的索引增加",
            "            swap(&arr[i], &arr[j]);",
            "        }",
            "    }",
            "",
            "    swap(&arr[i + 1], &arr[high]);",
            "    return i + 1;",
            "}",
            "",
            "// 快速排序函数",
            "void quickSort(int arr[], int low, int high) {",
            "    if (low < high) {",
            "        // 找到分割点的索引",
            "        int pi = partition(arr, low, high);",
            "",
            "        // 递归对分割点左边和右边的子数组进行排序",
            "        quickSort(arr, low, pi - 1);",
            "        quickSort(arr, pi + 1, high);",
            "    }",
            "}"
        ],
        "description": "Code snippet for quickSort"
    },
    "quickSortCn": {
        "prefix": "数组快速排序",
        "body": [
            "// 交换数组中两个元素的值",
            "void swap(int *a, int *b) {",
            "    int temp = *a;",
            "    *a = *b;",
            "    *b = temp;",
            "}",
            "",
            "// 分割数组，并返回分割点的索引",
            "int partition(int arr[], int low, int high) {",
            "    int pivot = arr[high]; // 选择最后一个元素作为枢纽元素",
            "    int i = low - 1; // 初始化较小元素的索引",
            "",
            "    for (int j = low; j <= high - 1; j++) {",
            "        if (arr[j] <= pivot) {",
            "            i++; // 较小元素的索引增加",
            "            swap(&arr[i], &arr[j]);",
            "        }",
            "    }",
            "",
            "    swap(&arr[i + 1], &arr[high]);",
            "    return i + 1;",
            "}",
            "",
            "// 快速排序函数",
            "void quickSort(int arr[], int low, int high) {",
            "    if (low < high) {",
            "        // 找到分割点的索引",
            "        int pi = partition(arr, low, high);",
            "",
            "        // 递归对分割点左边和右边的子数组进行排序",
            "        quickSort(arr, low, pi - 1);",
            "        quickSort(arr, pi + 1, high);",
            "    }",
            "}"
        ],
        "description": "Code snippet for quickSortCn"
    },
    "arrfindDuplicates": {
        "prefix": "arrfindDuplicates",
        "body": [
            "void findDuplicates(int arr[], int n) {",
            "    int i, j;",
            "    printf(重复元素：%d);",
            "    ",
            "    for (i = 0; i < n - 1; i++) {",
            "        for (j = i + 1; j < n; j++) {",
            "            if (arr[i] == arr[j]) {",
            "                printf(%d, arr[i]);",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Code snippet for arrfindDuplicates"
    },
    "arrfindDuplicatesCn": {
        "prefix": "数组查找重复元素",
        "body": [
            "void findDuplicates(int arr[], int n) {",
            "    int i, j;",
            "    printf(重复元素：%d);",
            "    ",
            "    for (i = 0; i < n - 1; i++) {",
            "        for (j = i + 1; j < n; j++) {",
            "            if (arr[i] == arr[j]) {",
            "                printf(%d, arr[i]);",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Code snippet for arrfindDuplicatesCn"
    },
    "findMaxAndMin": {
        "prefix": "arrFindMaxAndMin",
        "body": [
            "// 函数用于查找数组的最大值和最小值",
            "void findMaxAndMin(int arr[], int n, int *max, int *min) {",
            "    *max = *min = arr[0]; // 初始化最大值和最小值为数组的第一个元素",
            "",
            "    for (int i = 1; i < n; i++) {",
            "        if (arr[i] > *max) {",
            "            *max = arr[i]; // 更新最大值",
            "        }",
            "        if (arr[i] < *min) {",
            "            *min = arr[i]; // 更新最小值",
            "        }",
            "    }",
            "}"
        ],
        "description": "Code snippet for findMaxAndMin"
    },
    "findMaxAndMinCn": {
        "prefix": "数组查找最大值和最小值",
        "body": [
            "// 函数用于查找数组的最大值和最小值",
            "void findMaxAndMin(int arr[], int n, int *max, int *min) {",
            "    *max = *min = arr[0]; // 初始化最大值和最小值为数组的第一个元素",
            "",
            "    for (int i = 1; i < n; i++) {",
            "        if (arr[i] > *max) {",
            "            *max = arr[i]; // 更新最大值",
            "        }",
            "        if (arr[i] < *min) {",
            "            *min = arr[i]; // 更新最小值",
            "        }",
            "    }",
            "}"
        ],
        "description": "Code snippet for findMaxAndMin"
    },
    "mergeSortedArrays": {
        "prefix": "arrMergeSortedArrays",
        "body": [
            "void mergeSortedArrays(int arr1[], int m, int arr2[], int n, int merged[]) {",
            "    int i = 0; // 用于遍历 arr1",
            "    int j = 0; // 用于遍历 arr2",
            "    int k = 0; // 用于遍历 merged",
            "",
            "    while (i < m && j < n) {",
            "        if (arr1[i] < arr2[j]) {",
            "            merged[k++] = arr1[i++];",
            "        } else {",
            "            merged[k++] = arr2[j++];",
            "        }",
            "    }",
            "",
            "    // 将剩余元素复制到 merged 数组中",
            "    while (i < m) {",
            "        merged[k++] = arr1[i++];",
            "    }",
            "",
            "    while (j < n) {",
            "        merged[k++] = arr2[j++];",
            "    }",
            "}"
        ],
        "description": "Code snippet for arrMergeSortedArrays"
    },
    "mergeSortedArraysCN": {
        "prefix": "数组合并两个有序数组",
        "body": [
            "void mergeSortedArrays(int arr1[], int m, int arr2[], int n, int merged[]) {",
            "    int i = 0; // 用于遍历 arr1",
            "    int j = 0; // 用于遍历 arr2",
            "    int k = 0; // 用于遍历 merged",
            "",
            "    while (i < m && j < n) {",
            "        if (arr1[i] < arr2[j]) {",
            "            merged[k++] = arr1[i++];",
            "        } else {",
            "            merged[k++] = arr2[j++];",
            "        }",
            "    }",
            "",
            "    // 将剩余元素复制到 merged 数组中",
            "    while (i < m) {",
            "        merged[k++] = arr1[i++];",
            "    }",
            "",
            "    while (j < n) {",
            "        merged[k++] = arr2[j++];",
            "    }",
            "}"
        ],
        "description": "Code snippet for arrMergeSortedArrays"
    },
    "countElement": {
        "prefix": "arrCountElement",
        "body": [
            "int countElement(int arr[], int n, int target) {",
            "    int count = 0; // 初始化计数器为0",
            "",
            "    // 遍历数组并计数目标元素的出现次数",
            "    for (int i = 0; i < n; i++) {",
            "        if (arr[i] == target) {",
            "            count++;",
            "        }",
            "    }",
            "",
            "    return count;",
            "}"
        ],
        "description": "Code snippet for arrCountElement"
    },
    "countElementCn": {
        "prefix": "数组计数元素出现次数",
        "body": [
            "int countElement(int arr[], int n, int target) {",
            "    int count = 0; // 初始化计数器为0",
            "",
            "    // 遍历数组并计数目标元素的出现次数",
            "    for (int i = 0; i < n; i++) {",
            "        if (arr[i] == target) {",
            "            count++;",
            "        }",
            "    }",
            "",
            "    return count;",
            "}"
        ],
        "description": "Code snippet for arrCountElement"
    },
    "arrElemSum": {
        "prefix": "arrElemSum",
        "body": [
            " int arrElemSum(int arr[], int n)",
            " {",
            "    int sum = 0; // 初始化总和为0",
            "",
            "    // 遍历数组并计算总和",
            "    for (int i = 0; i < n; i++) {",
            "        sum += arr[i];",
            "    }",
            "    return sum;",
            " }"
        ],
        "description": "Code snippet for arrElemSum"
    },
    "arrElemSumCn": {
        "prefix": "数组求和",
        "body": [
            " int arrElemSum(int arr[], int n)",
            " {",
            "    int sum = 0; // 初始化总和为0",
            "",
            "    // 遍历数组并计算总和",
            "    for (int i = 0; i < n; i++) {",
            "        sum += arr[i];",
            "    }",
            "    return sum;",
            " }"
        ],
        "description": "Code snippet for arrElemSum"
    },
    "calculateMedian": {
        "prefix": "arrCalculateMedian",
        "body": [
            "// 比较函数，用于qsort排序",
            "int compare(const void *a, const void *b) {",
            "    return (*(int*)a - *(int*)b);",
            "}",
            "",
            "// 计算中位数的函数",
            "int calculateMedian(int data[], int n) {",
            "    // 对数据进行排序",
            "    qsort(data, n, sizeof(int), compare);",
            "",
            "    // 中位数的位置取决于数据的个数",
            "    int median;",
            "    if (n % 2 == 0) {",
            "        median = (data[n / 2 - 1] + data[n / 2]) / 2;",
            "    } else {",
            "        median = data[n / 2];",
            "    }",
            "",
            "    return median;",
            "}"
        ],
        "description": "Code snippet for arrCalculateMedian"
    },
    "calculateMedianCn": {
        "prefix": "数组查找中位数",
        "body": [
            "// 比较函数，用于qsort排序",
            "int compare(const void *a, const void *b) {",
            "    return (*(int*)a - *(int*)b);",
            "}",
            "",
            "// 计算中位数的函数",
            "int calculateMedian(int data[], int n) {",
            "    // 对数据进行排序",
            "    qsort(data, n, sizeof(int), compare);",
            "",
            "    // 中位数的位置取决于数据的个数",
            "    int median;",
            "    if (n % 2 == 0) {",
            "        median = (data[n / 2 - 1] + data[n / 2]) / 2;",
            "    } else {",
            "        median = data[n / 2];",
            "    }",
            "",
            "    return median;",
            "}"
        ],
        "description": "Code snippet for arrCalculateMedian"
    },
    "runStateMachine": {
        "prefix": "runStateMachine",
        "body": [
            "// 定义状态枚举",
            "enum State {",
            "    STATE_IDLE,",
            "    STATE_START,",
            "    STATE_RUNNING,",
            "    STATE_PAUSE,",
            "    STATE_RESUME,",
            "    STATE_STOP",
            "};",
            "",
            "// 定义状态机函数",
            "enum State runStateMachine(enum State currentState) {",
            "    switch (currentState) {",
            "        case STATE_IDLE:",
            "            return STATE_START;",
            "",
            "        case STATE_START:",
            "            return STATE_RUNNING;",
            "",
            "        case STATE_RUNNING:",
            "            // 这里可以添加运行时的操作",
            "            return STATE_PAUSE;",
            "",
            "        case STATE_PAUSE:",
            "            // 这里可以添加暂停时的操作",
            "            return STATE_RESUME;",
            "",
            "        case STATE_RESUME:",
            "            // 这里可以添加恢复时的操作",
            "            return STATE_RUNNING;",
            "",
            "        case STATE_STOP:",
            "            // 这里可以添加停止时的操作",
            "            return STATE_IDLE;",
            "    }",
            "",
            "    // 默认情况下返回当前状态",
            "    return currentState;",
            "}"
        ],
        "description": "Code snippet for runStateMachine"
    },
    "runStateMachineCn": {
        "prefix": "状态机",
        "body": [
            "// 定义状态枚举",
            "enum State {",
            "    STATE_IDLE,",
            "    STATE_START,",
            "    STATE_RUNNING,",
            "    STATE_PAUSE,",
            "    STATE_RESUME,",
            "    STATE_STOP",
            "};",
            "",
            "// 定义状态机函数",
            "enum State runStateMachine(enum State currentState) {",
            "    switch (currentState) {",
            "        case STATE_IDLE:",
            "            return STATE_START;",
            "",
            "        case STATE_START:",
            "            return STATE_RUNNING;",
            "",
            "        case STATE_RUNNING:",
            "            // 这里可以添加运行时的操作",
            "            return STATE_PAUSE;",
            "",
            "        case STATE_PAUSE:",
            "            // 这里可以添加暂停时的操作",
            "            return STATE_RESUME;",
            "",
            "        case STATE_RESUME:",
            "            // 这里可以添加恢复时的操作",
            "            return STATE_RUNNING;",
            "",
            "        case STATE_STOP:",
            "            // 这里可以添加停止时的操作",
            "            return STATE_IDLE;",
            "    }",
            "",
            "    // 默认情况下返回当前状态",
            "    return currentState;",
            "}"
        ],
        "description": "Code snippet for runStateMachine"
    },
    "removeNthFromEnd": {
        "prefix": "listRemoveNthFromEnd",
        "body": [
            "/**",
            " * Definition for singly-linked list.",
            " * struct ListNode {",
            " *     int val;",
            " *     struct ListNode *next;",
            " * };",
            " */",
            "",
            "struct ListNode *removeNthFromEnd(struct ListNode *head, int n) {",
            "    struct ListNode entry, *p_free, *p = head;",
            "    int i, sz = 0;",
            "    entry.next = head;",
            "    while (p != NULL) {",
            "        p = p->next;",
            "        sz++;",
            "    }",
            "    for (i = 0, p = &entry; i < sz - n; i++, p = p -> next)",
            "    ;",
            "    p_free = p->next;",
            "    if (n != 1) {",
            "        p->next = p->next->next;",
            "    } else {",
            "        p->next = NULL;",
            "    }",
            "    free(p_free);",
            "    return entry.next;",
            "}"
        ],
        "description": "Code snippet for listRemoveNthFromEnd"
    },
    "removeNthFromEndCn": {
        "prefix": "链表删除倒数第N个节点",
        "body": [
            "/**",
            " * Definition for singly-linked list.",
            " * struct ListNode {",
            " *     int val;",
            " *     struct ListNode *next;",
            " * };",
            " */",
            "",
            "struct ListNode *removeNthFromEnd(struct ListNode *head, int n) {",
            "    struct ListNode entry, *p_free, *p = head;",
            "    int i, sz = 0;",
            "    entry.next = head;",
            "    while (p != NULL) {",
            "        p = p->next;",
            "        sz++;",
            "    }",
            "    for (i = 0, p = &entry; i < sz - n; i++, p = p -> next)",
            "    ;",
            "    p_free = p->next;",
            "    if (n != 1) {",
            "        p->next = p->next->next;",
            "    } else {",
            "        p->next = NULL;",
            "    }",
            "    free(p_free);",
            "    return entry.next;",
            "}"
        ],
        "description": "Code snippet for listRemoveNthFromEnd"
    },
    "reverseBits": {
        "prefix": "reverseBits",
        "body": [
            "uint32_t reverseBits(uint32_t n)",
            "{",
            "    uint TotalBits = 32;",
            "    uint32_t reverse_int = 0;  // stored in memory as 32 bits, each bit valued 0",
            "    uint i;",
            "    for (i = 0; i < TotalBits; i++)",
            "    {",
            "        if ((n & (UINT32_C(1)",
            "                  << i)))  // if the bit on the ith position of 32 bit input is",
            "                           // 1, then proceed Further note the use of UINT32_C",
            "                           // to convert 1 to unsigned 32 bit int, since just 1",
            "                           // is treated as int which cannot be shifted left",
            "                           // more than 30 times",
            "            reverse_int =",
            "                reverse_int |",
            "                (UINT32_C(1)",
            "                 << (TotalBits - 1 -",
            "                     i));  // Convert the ith bit from the end in reverse_int",
            "                           // from 0 to 1, if ith bit from beginning in n is 1",
            "                           // This is achieved by using bitwise OR on",
            "                           // reverse_int (where ith bit from end is currently",
            "                           // 0) and 1 shifted left 31 - i bits (to ith bit from",
            "                           // the end)",
            "    }",
            "    return reverse_int;",
            "}"
        ],
        "description": "Code snippet for reverseBits"
    },
    "reverseBitsCN": {
        "prefix": "位反转uint32",
        "body": [
            "uint32_t reverseBits(uint32_t n)",
            "{",
            "    uint TotalBits = 32;",
            "    uint32_t reverse_int = 0;  // stored in memory as 32 bits, each bit valued 0",
            "    uint i;",
            "    for (i = 0; i < TotalBits; i++)",
            "    {",
            "        if ((n & (UINT32_C(1)",
            "                  << i)))  // if the bit on the ith position of 32 bit input is",
            "                           // 1, then proceed Further note the use of UINT32_C",
            "                           // to convert 1 to unsigned 32 bit int, since just 1",
            "                           // is treated as int which cannot be shifted left",
            "                           // more than 30 times",
            "            reverse_int =",
            "                reverse_int |",
            "                (UINT32_C(1)",
            "                 << (TotalBits - 1 -",
            "                     i));  // Convert the ith bit from the end in reverse_int",
            "                           // from 0 to 1, if ith bit from beginning in n is 1",
            "                           // This is achieved by using bitwise OR on",
            "                           // reverse_int (where ith bit from end is currently",
            "                           // 0) and 1 shifted left 31 - i bits (to ith bit from",
            "                           // the end)",
            "    }",
            "    return reverse_int;",
            "}"
        ],
        "description": "Code snippet for reverseBits"
    },
    "hammingWeight": {
        "prefix": "hammingWeight",
        "body": [
            "int hammingWeight(uint32_t n)",
            "{",
            "    int TotalBits = 32;",
            "    int i, weight = 0;",
            "    for (i = 0; i < TotalBits; i++)",
            "    {",
            "        if (n &",
            "            (UINT32_C(1)",
            "             << i))  // if the bit on the ith position of 32 bit input is 1,",
            "                     // then proceed Further note the use of UINT32_C to",
            "                     // convert 1 to unsigned 32 bit int, as just 1 is treated",
            "                     // as int which cannot be shifted left more than 30 times",
            "            weight += 1;",
            "    }",
            "    return weight;",
            "}"
        ],
        "description": "Code snippet for hammingWeight"
    },
    "hammingWeightCN": {
        "prefix": "求二进制1的个数",
        "body": [
            "int hammingWeight(uint32_t n)",
            "{",
            "    int TotalBits = 32;",
            "    int i, weight = 0;",
            "    for (i = 0; i < TotalBits; i++)",
            "    {",
            "        if (n &",
            "            (UINT32_C(1)",
            "             << i))  // if the bit on the ith position of 32 bit input is 1,",
            "                     // then proceed Further note the use of UINT32_C to",
            "                     // convert 1 to unsigned 32 bit int, as just 1 is treated",
            "                     // as int which cannot be shifted left more than 30 times",
            "            weight += 1;",
            "    }",
            "    return weight;",
            "}"
        ],
        "description": "Code snippet for hammingWeight"
    },
    "isValidBrackets": {
        "prefix": "isValidBrackets",
        "body": [
            "bool isValidBrackets(char *s)",
            "{",
            "    int i, k = 0, len = strlen(s);",
            "    char *store = calloc(len, sizeof(char));",
            "",
            "    for (i = 0; s[i] != 0; i++)",
            "    {",
            "        switch (s[i])",
            "        {",
            "        case '(':",
            "        case '{':",
            "        case '[':",
            "            store[k++] = s[i];",
            "            break;",
            "        case ')':",
            "            if (k < 1 || store[--k] != '(')",
            "                goto out;",
            "            break;",
            "        case '}':",
            "            if (k < 1 || store[--k] != '{')",
            "                goto out;",
            "            break;",
            "        case ']':",
            "            if (k < 1 || store[--k] != '[')",
            "                goto out;",
            "            break;",
            "        }",
            "    }",
            "out:",
            "    free(store);",
            "    return s[i] == '0' && k == 0;",
            "}"
        ],
        "description": "Code snippet for isValidBrackets"
    },
    "isValidBracketsCN": {
        "prefix": "检查括号配对",
        "body": [
            "bool isValidBrackets(char *s)",
            "{",
            "    int i, k = 0, len = strlen(s);",
            "    char *store = calloc(len, sizeof(char));",
            "",
            "    for (i = 0; s[i] != 0; i++)",
            "    {",
            "        switch (s[i])",
            "        {",
            "        case '(':",
            "        case '{':",
            "        case '[':",
            "            store[k++] = s[i];",
            "            break;",
            "        case ')':",
            "            if (k < 1 || store[--k] != '(')",
            "                goto out;",
            "            break;",
            "        case '}':",
            "            if (k < 1 || store[--k] != '{')",
            "                goto out;",
            "            break;",
            "        case ']':",
            "            if (k < 1 || store[--k] != '[')",
            "                goto out;",
            "            break;",
            "        }",
            "    }",
            "out:",
            "    free(store);",
            "    return s[i] == '0' && k == 0;",
            "}"
        ],
        "description": "Code snippet for isValidBrackets"
    },
    "rangeBitwiseAnd": {
        "prefix": "bitwiseAnd",
        "body": [
            "int rangeBitwiseAnd(int m, int n)",
            "{",
            "    while (m < n)",
            "    {",
            "        n &= n - 1;",
            "    }",
            "    return n;",
            "}"
        ],
        "description": "Code snippet for rangeBitwiseAnd statement"
    },
    "rangeBitwiseAndCN": {
        "prefix": "位与",
        "body": [
            "int rangeBitwiseAnd(int m, int n)",
            "{",
            "    while (m < n)",
            "    {",
            "        n &= n - 1;",
            "    }",
            "    return n;",
            "}"
        ],
        "description": "Code snippet for rangeBitwiseAndCN statement"
    },
    "listRemoveValElements": {
        "prefix": "listRemoveValElements",
        "body": [
            "struct ListNode *removeElements(struct ListNode *head, int val)",
            "{",
            "    if (head == NULL)",
            "        return NULL;",
            "    if (head->val == val)",
            "    {",
            "        return removeElements(head->next, val);",
            "    }",
            "    else",
            "    {",
            "        head->next = removeElements(head->next, val);",
            "    }",
            "    return head;",
            "}",
        ],
        "description": "Code snippet for listRemoveValElements statement"
    },
    "listRemoveValElementsCN": {
        "prefix": "链表删除给定值",
        "body": [
            "struct ListNode *removeElements(struct ListNode *head, int val)",
            "{",
            "    if (head == NULL)",
            "        return NULL;",
            "    if (head->val == val)",
            "    {",
            "        return removeElements(head->next, val);",
            "    }",
            "    else",
            "    {",
            "        head->next = removeElements(head->next, val);",
            "    }",
            "    return head;",
            "}"
        ],
        "description": "Code snippet for listRemoveValElements statement"
    },
    "listReverseList": {
        "prefix": "listReverseList",
        "body": [
            "/**",
            " * Definition for singly-linked list.",
            " * struct ListNode {",
            " *     int val;",
            " *     struct ListNode *next;",
            " * };",
            " */",
            "",
            "struct ListNode *reverseList(struct ListNode *head)",
            "{",
            "    struct ListNode *res = NULL;",
            "    while (head)",
            "    {",
            "        struct ListNode *pre_node = head;",
            "        head = head->next;",
            "        pre_node->next = res;",
            "        res = pre_node;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Code snippet for listReverseList statement"
    },
    "listReverseListCN": {
        "prefix": "链表反转",
        "body": [
            "/**",
            " * Definition for singly-linked list.",
            " * struct ListNode {",
            " *     int val;",
            " *     struct ListNode *next;",
            " * };",
            " */",
            "",
            "struct ListNode *reverseList(struct ListNode *head)",
            "{",
            "    struct ListNode *res = NULL;",
            "    while (head)",
            "    {",
            "        struct ListNode *pre_node = head;",
            "        head = head->next;",
            "        pre_node->next = res;",
            "        res = pre_node;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Code snippet for listReverseList statement"
    },
    "switch": {
        "prefix": "switch",
        "body": [
            "swi"
        ],
        "description": "Code snippet for switch statement"
    }
}