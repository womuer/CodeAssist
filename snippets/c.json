{
    "for": {
        "prefix": "for",
        "body": [
            "for (${size_t} ${i} = ${1:0}; ${i} < ${2:length}; ${i}++)",
            "{",
			"	$3",
            "}"
        ],
        "description": "Code snippet for 'for' loop"
    },
    "forr": {
        "prefix": "forr",
        "body": [
            "for (int ${i} = ${1:length} - 1; ${i} >= ${2:0}; ${i}--)",
            "{",
			"	$3",
            "}"
        ],
        "description": "Code snippet for reverse 'for' loop"
    },
    "while": {
        "prefix": "while",
        "body": [
            "while ($1)",
            "{",
			"	$2",
            "}"
        ],
        "description": ""
    },
    "if": {
        "prefix": "if",
        "body": [
            "if ($1)",
            "{",
			"	$2",
            "}"
        ],
        "description": "Code snippet for if statement"
    },
    "else": {
        "prefix": "else",
        "body": [
            "else",
            "{",
			"	$1",
            "}"
        ],
        "description": "Code snippet for else statement"
    },
    "else if": {
        "prefix": "else if",
        "body": [
            "else if ($1)",
            "{",
			"	$2",
            "}"
        ],
        "description": "Code snippet for else-if statement"
    },
    "enum": {
        "prefix": "enum",
        "body": [
            "enum ${MyEnum}",
            "{",
			"	$1",
            "};"
        ],
        "description": "Code snippet for enum"
    },
    "#ifdef": {
        "prefix": "#ifdef",
        "body": [
            "#ifdef ${DEBUG}",
            "$1",
            "#endif // ${DEBUG}"
        ],
        "description": "Code snippet for #ifdef"
    },
    "#ifndef": {
        "prefix": "#ifndef",
        "body": [
            "#ifndef ${1:1}",
            "$2",
            "#endif // !$1"
        ],
        "description": "Code snippet for #ifndef"
    },
    "#if": {
        "prefix": "#if",
        "body": [
            "#ifdef ${1:0}",
            "$2",
            "#endif // $1"
        ],
        "description": "Code snippet for #if"
    },
    "struct": {
        "prefix": "struct",
        "body": [
            "struct ${MyStruct}",
            "{",
			"	$1",
            "};"
        ],
        "description": "Code snippet for struct"
    },
    "switch": {
        "prefix": "switch",
        "body": [
            "switch (${switch_on})",
            "{",
            "default:",
			"	break;$1",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "union": {
        "prefix": "union",
        "body": [
            "union ${MyUnion}",
            "{",
			"	$1",
            "};"
        ],
        "description": "Code snippet for union"
    },
    "#inc": {
        "prefix": "#inc",
        "body": [
            "#include \"$1\""
        ],
        "description": "Code snippet for #include \" \""
    },
    "#inc<": {
        "prefix": "#inc<",
        "body": [
            "#include <$1>"
        ],
        "description": "Code snippet for #include \" \""
    },
    "#def": {
        "prefix": "#def",
        "body": [
            "#define \"$1\" \"$2\" "
        ],
        "description": "Code snippet for #define \" \""
    },
    "#def": {
        "prefix": "#def",
        "body": [
            "#define \"$1\" \"$2\" "
        ],
        "description": "Code snippet for #define \" \""
    },
    "bubblesort": {
        "prefix": "arrBubblesort",
        "body": [
            "// 冒泡排序函数",
            "void bubbleSort(int arr[], int n) {",
            "    int temp;",
            "    int swapped;",
            "",
            "    for (int i = 0; i < n - 1; i++) {",
            "        swapped = 0; // 用于标记是否发生了交换",
            "",
            "        for (int j = 0; j < n - i - 1; j++) {",
            "            if (arr[j] > arr[j + 1]) {",
            "                // 交换arr[j]和arr[j+1]的位置",
            "                temp = arr[j];",
            "                arr[j] = arr[j + 1];",
            "                arr[j + 1] = temp;",
            "                swapped = 1; // 标记已发生交换",
            "            }",
            "        }",
            "",
            "        // 如果在本轮没有发生交换，说明数组已经有序，可以提前退出",
            "        if (swapped == 0) {",
            "            break;",
            "        }",
            "    }",
            "}"
        ],
        "description": "Code snippet forbubblesort \" \""
    },
    "bubblesort_cn": {
        "prefix": "数组冒泡排序",
        "body": [
            "// 冒泡排序函数",
            "void bubbleSort(int arr[], int n) {",
            "    int temp;",
            "    int swapped;",
            "",
            "    for (int i = 0; i < n - 1; i++) {",
            "        swapped = 0; // 用于标记是否发生了交换",
            "",
            "        for (int j = 0; j < n - i - 1; j++) {",
            "            if (arr[j] > arr[j + 1]) {",
            "                // 交换arr[j]和arr[j+1]的位置",
            "                temp = arr[j];",
            "                arr[j] = arr[j + 1];",
            "                arr[j + 1] = temp;",
            "                swapped = 1; // 标记已发生交换",
            "            }",
            "        }",
            "",
            "        // 如果在本轮没有发生交换，说明数组已经有序，可以提前退出",
            "        if (swapped == 0) {",
            "            break;",
            "        }",
            "    }",
            "}"
        ],
        "description": "Code snippet forbubblesort \" \""
    },
    "find_min_arr": {
        "prefix": "arrFindminarr",
        "body": [
            "int findMin(int arr[], int n) {",
            "    if (n <= 0) {",
            "        // 处理无效输入",
            "        printf(error);",
            "        return -1; // 返回一个标志值表示错误",
            "    }",
            "",
            "    int min = arr[0]; // 假定第一个元素为最小值",
            "",
            "    // 遍历数组，比较找到最小值",
            "    for (int i = 1; i < n; i++) {",
            "        if (arr[i] < min) {",
            "            min = arr[i]; // 更新最小值",
            "        }",
            "    }",
            "",
            "    return min;",
            "}"
        ],
        "description": "Code snippet for findminarr"
    },
    "find_min_arr_cn": {
        "prefix": "数组查找数组最小值",
        "body": [
            "int findMin(int arr[], int n) {",
            "    if (n <= 0) {",
            "        // 处理无效输入",
            "        printf(error);",
            "        return -1; // 返回一个标志值表示错误",
            "    }",
            "",
            "    int min = arr[0]; // 假定第一个元素为最小值",
            "",
            "    // 遍历数组，比较找到最小值",
            "    for (int i = 1; i < n; i++) {",
            "        if (arr[i] < min) {",
            "            min = arr[i]; // 更新最小值",
            "        }",
            "    }",
            "",
            "    return min;",
            "}"
        ],
        "description": "Code snippet for 查找数组最小值"
    },
    "selectionSort": {
        "prefix": "arrSelectionSort",
        "body": [
            "// 选择排序函数",
            "void selectionSort(int arr[], int n) {",
            "    int i, j, minIndex, temp;",
            "    ",
            "    for (i = 0; i < n - 1; i++) {",
            "        minIndex = i; // 假定未排序部分的第一个元素是最小的",
            "        for (j = i + 1; j < n; j++) {",
            "            // 寻找未排序部分中的最小元素的索引",
            "            if (arr[j] < arr[minIndex]) {",
            "                minIndex = j;",
            "            }",
            "        }",
            "",
            "        // 交换未排序部分的第一个元素和最小元素",
            "        temp = arr[i];",
            "        arr[i] = arr[minIndex];",
            "        arr[minIndex] = temp;",
            "    }",
            "}"
        ],
        "description": "Code snippet for selectionSort"
    },
    "selectionSortCn": {
        "prefix": "数组选择排序",
        "body": [
            "// 选择排序函数",
            "void selectionSort(int arr[], int n) {",
            "    int i, j, minIndex, temp;",
            "    ",
            "    for (i = 0; i < n - 1; i++) {",
            "        minIndex = i; // 假定未排序部分的第一个元素是最小的",
            "        for (j = i + 1; j < n; j++) {",
            "            // 寻找未排序部分中的最小元素的索引",
            "            if (arr[j] < arr[minIndex]) {",
            "                minIndex = j;",
            "            }",
            "        }",
            "",
            "        // 交换未排序部分的第一个元素和最小元素",
            "        temp = arr[i];",
            "        arr[i] = arr[minIndex];",
            "        arr[minIndex] = temp;",
            "    }",
            "}"
        ],
        "description": "Code snippet for selectionSort"
    },
    "quickSort": {
        "prefix": "arrQuickSort",
        "body": [
            "// 交换数组中两个元素的值",
            "void swap(int *a, int *b) {",
            "    int temp = *a;",
            "    *a = *b;",
            "    *b = temp;",
            "}",
            "",
            "// 分割数组，并返回分割点的索引",
            "int partition(int arr[], int low, int high) {",
            "    int pivot = arr[high]; // 选择最后一个元素作为枢纽元素",
            "    int i = low - 1; // 初始化较小元素的索引",
            "",
            "    for (int j = low; j <= high - 1; j++) {",
            "        if (arr[j] <= pivot) {",
            "            i++; // 较小元素的索引增加",
            "            swap(&arr[i], &arr[j]);",
            "        }",
            "    }",
            "",
            "    swap(&arr[i + 1], &arr[high]);",
            "    return i + 1;",
            "}",
            "",
            "// 快速排序函数",
            "void quickSort(int arr[], int low, int high) {",
            "    if (low < high) {",
            "        // 找到分割点的索引",
            "        int pi = partition(arr, low, high);",
            "",
            "        // 递归对分割点左边和右边的子数组进行排序",
            "        quickSort(arr, low, pi - 1);",
            "        quickSort(arr, pi + 1, high);",
            "    }",
            "}"
        ],
        "description": "Code snippet for quickSort"
    },
    "quickSortCn": {
        "prefix": "数组快速排序",
        "body": [
            "// 交换数组中两个元素的值",
            "void swap(int *a, int *b) {",
            "    int temp = *a;",
            "    *a = *b;",
            "    *b = temp;",
            "}",
            "",
            "// 分割数组，并返回分割点的索引",
            "int partition(int arr[], int low, int high) {",
            "    int pivot = arr[high]; // 选择最后一个元素作为枢纽元素",
            "    int i = low - 1; // 初始化较小元素的索引",
            "",
            "    for (int j = low; j <= high - 1; j++) {",
            "        if (arr[j] <= pivot) {",
            "            i++; // 较小元素的索引增加",
            "            swap(&arr[i], &arr[j]);",
            "        }",
            "    }",
            "",
            "    swap(&arr[i + 1], &arr[high]);",
            "    return i + 1;",
            "}",
            "",
            "// 快速排序函数",
            "void quickSort(int arr[], int low, int high) {",
            "    if (low < high) {",
            "        // 找到分割点的索引",
            "        int pi = partition(arr, low, high);",
            "",
            "        // 递归对分割点左边和右边的子数组进行排序",
            "        quickSort(arr, low, pi - 1);",
            "        quickSort(arr, pi + 1, high);",
            "    }",
            "}"
        ],
        "description": "Code snippet for quickSortCn"
    },
    "arrfindDuplicates": {
        "prefix": "arrfindDuplicates",
        "body": [
            "void findDuplicates(int arr[], int n) {",
            "    int i, j;",
            "    printf(重复元素：%d);",
            "    ",
            "    for (i = 0; i < n - 1; i++) {",
            "        for (j = i + 1; j < n; j++) {",
            "            if (arr[i] == arr[j]) {",
            "                printf(%d, arr[i]);",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Code snippet for arrfindDuplicates"
    },
    "arrfindDuplicatesCn": {
        "prefix": "数组查找重复元素",
        "body": [
            "void findDuplicates(int arr[], int n) {",
            "    int i, j;",
            "    printf(重复元素：%d);",
            "    ",
            "    for (i = 0; i < n - 1; i++) {",
            "        for (j = i + 1; j < n; j++) {",
            "            if (arr[i] == arr[j]) {",
            "                printf(%d, arr[i]);",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Code snippet for arrfindDuplicatesCn"
    },
    "findMaxAndMin": {
        "prefix": "arrFindMaxAndMin",
        "body": [
            "// 函数用于查找数组的最大值和最小值",
            "void findMaxAndMin(int arr[], int n, int *max, int *min) {",
            "    *max = *min = arr[0]; // 初始化最大值和最小值为数组的第一个元素",
            "",
            "    for (int i = 1; i < n; i++) {",
            "        if (arr[i] > *max) {",
            "            *max = arr[i]; // 更新最大值",
            "        }",
            "        if (arr[i] < *min) {",
            "            *min = arr[i]; // 更新最小值",
            "        }",
            "    }",
            "}"
        ],
        "description": "Code snippet for findMaxAndMin"
    },
    "findMaxAndMinCn": {
        "prefix": "数组查找最大值和最小值",
        "body": [
            "// 函数用于查找数组的最大值和最小值",
            "void findMaxAndMin(int arr[], int n, int *max, int *min) {",
            "    *max = *min = arr[0]; // 初始化最大值和最小值为数组的第一个元素",
            "",
            "    for (int i = 1; i < n; i++) {",
            "        if (arr[i] > *max) {",
            "            *max = arr[i]; // 更新最大值",
            "        }",
            "        if (arr[i] < *min) {",
            "            *min = arr[i]; // 更新最小值",
            "        }",
            "    }",
            "}"
        ],
        "description": "Code snippet for findMaxAndMin"
    },
    "mergeSortedArrays": {
        "prefix": "arrMergeSortedArrays",
        "body": [
            "void mergeSortedArrays(int arr1[], int m, int arr2[], int n, int merged[]) {",
            "    int i = 0; // 用于遍历 arr1",
            "    int j = 0; // 用于遍历 arr2",
            "    int k = 0; // 用于遍历 merged",
            "",
            "    while (i < m && j < n) {",
            "        if (arr1[i] < arr2[j]) {",
            "            merged[k++] = arr1[i++];",
            "        } else {",
            "            merged[k++] = arr2[j++];",
            "        }",
            "    }",
            "",
            "    // 将剩余元素复制到 merged 数组中",
            "    while (i < m) {",
            "        merged[k++] = arr1[i++];",
            "    }",
            "",
            "    while (j < n) {",
            "        merged[k++] = arr2[j++];",
            "    }",
            "}"
        ],
        "description": "Code snippet for arrMergeSortedArrays"
    },
    "mergeSortedArraysCN": {
        "prefix": "数组合并两个有序数组",
        "body": [
            "void mergeSortedArrays(int arr1[], int m, int arr2[], int n, int merged[]) {",
            "    int i = 0; // 用于遍历 arr1",
            "    int j = 0; // 用于遍历 arr2",
            "    int k = 0; // 用于遍历 merged",
            "",
            "    while (i < m && j < n) {",
            "        if (arr1[i] < arr2[j]) {",
            "            merged[k++] = arr1[i++];",
            "        } else {",
            "            merged[k++] = arr2[j++];",
            "        }",
            "    }",
            "",
            "    // 将剩余元素复制到 merged 数组中",
            "    while (i < m) {",
            "        merged[k++] = arr1[i++];",
            "    }",
            "",
            "    while (j < n) {",
            "        merged[k++] = arr2[j++];",
            "    }",
            "}"
        ],
        "description": "Code snippet for arrMergeSortedArrays"
    },
    "countElement": {
        "prefix": "arrCountElement",
        "body": [
            "int countElement(int arr[], int n, int target) {",
            "    int count = 0; // 初始化计数器为0",
            "",
            "    // 遍历数组并计数目标元素的出现次数",
            "    for (int i = 0; i < n; i++) {",
            "        if (arr[i] == target) {",
            "            count++;",
            "        }",
            "    }",
            "",
            "    return count;",
            "}"
        ],
        "description": "Code snippet for arrCountElement"
    },
    "countElementCn": {
        "prefix": "数组计数元素出现次数",
        "body": [
            "int countElement(int arr[], int n, int target) {",
            "    int count = 0; // 初始化计数器为0",
            "",
            "    // 遍历数组并计数目标元素的出现次数",
            "    for (int i = 0; i < n; i++) {",
            "        if (arr[i] == target) {",
            "            count++;",
            "        }",
            "    }",
            "",
            "    return count;",
            "}"
        ],
        "description": "Code snippet for arrCountElement"
    },
    "arrElemSum": {
        "prefix": "arrElemSum",
        "body": [
            " int arrElemSum(int arr[], int n)",
            " {",
            "    int sum = 0; // 初始化总和为0",
            "",
            "    // 遍历数组并计算总和",
            "    for (int i = 0; i < n; i++) {",
            "        sum += arr[i];",
            "    }",
            "    return sum;",
            " }"
        ],
        "description": "Code snippet for arrElemSum"
    },
    "arrElemSumCn": {
        "prefix": "数组求和",
        "body": [
            " int arrElemSum(int arr[], int n)",
            " {",
            "    int sum = 0; // 初始化总和为0",
            "",
            "    // 遍历数组并计算总和",
            "    for (int i = 0; i < n; i++) {",
            "        sum += arr[i];",
            "    }",
            "    return sum;",
            " }"
        ],
        "description": "Code snippet for arrElemSum"
    },
    "calculateMedian": {
        "prefix": "arrCalculateMedian",
        "body": [
            "// 比较函数，用于qsort排序",
            "int compare(const void *a, const void *b) {",
            "    return (*(int*)a - *(int*)b);",
            "}",
            "",
            "// 计算中位数的函数",
            "int calculateMedian(int data[], int n) {",
            "    // 对数据进行排序",
            "    qsort(data, n, sizeof(int), compare);",
            "",
            "    // 中位数的位置取决于数据的个数",
            "    int median;",
            "    if (n % 2 == 0) {",
            "        median = (data[n / 2 - 1] + data[n / 2]) / 2;",
            "    } else {",
            "        median = data[n / 2];",
            "    }",
            "",
            "    return median;",
            "}"
        ],
        "description": "Code snippet for arrCalculateMedian"
    },
    "calculateMedianCn": {
        "prefix": "数组查找中位数",
        "body": [
            "// 比较函数，用于qsort排序",
            "int compare(const void *a, const void *b) {",
            "    return (*(int*)a - *(int*)b);",
            "}",
            "",
            "// 计算中位数的函数",
            "int calculateMedian(int data[], int n) {",
            "    // 对数据进行排序",
            "    qsort(data, n, sizeof(int), compare);",
            "",
            "    // 中位数的位置取决于数据的个数",
            "    int median;",
            "    if (n % 2 == 0) {",
            "        median = (data[n / 2 - 1] + data[n / 2]) / 2;",
            "    } else {",
            "        median = data[n / 2];",
            "    }",
            "",
            "    return median;",
            "}"
        ],
        "description": "Code snippet for arrCalculateMedian"
    },
    "runStateMachine": {
        "prefix": "runStateMachine",
        "body": [
            "// 定义状态枚举",
            "enum State {",
            "    STATE_IDLE,",
            "    STATE_START,",
            "    STATE_RUNNING,",
            "    STATE_PAUSE,",
            "    STATE_RESUME,",
            "    STATE_STOP",
            "};",
            "",
            "// 定义状态机函数",
            "enum State runStateMachine(enum State currentState) {",
            "    switch (currentState) {",
            "        case STATE_IDLE:",
            "            return STATE_START;",
            "",
            "        case STATE_START:",
            "            return STATE_RUNNING;",
            "",
            "        case STATE_RUNNING:",
            "            // 这里可以添加运行时的操作",
            "            return STATE_PAUSE;",
            "",
            "        case STATE_PAUSE:",
            "            // 这里可以添加暂停时的操作",
            "            return STATE_RESUME;",
            "",
            "        case STATE_RESUME:",
            "            // 这里可以添加恢复时的操作",
            "            return STATE_RUNNING;",
            "",
            "        case STATE_STOP:",
            "            // 这里可以添加停止时的操作",
            "            return STATE_IDLE;",
            "    }",
            "",
            "    // 默认情况下返回当前状态",
            "    return currentState;",
            "}"
        ],
        "description": "Code snippet for runStateMachine"
    },
    "runStateMachineCn": {
        "prefix": "状态机",
        "body": [
            "// 定义状态枚举",
            "enum State {",
            "    STATE_IDLE,",
            "    STATE_START,",
            "    STATE_RUNNING,",
            "    STATE_PAUSE,",
            "    STATE_RESUME,",
            "    STATE_STOP",
            "};",
            "",
            "// 定义状态机函数",
            "enum State runStateMachine(enum State currentState) {",
            "    switch (currentState) {",
            "        case STATE_IDLE:",
            "            return STATE_START;",
            "",
            "        case STATE_START:",
            "            return STATE_RUNNING;",
            "",
            "        case STATE_RUNNING:",
            "            // 这里可以添加运行时的操作",
            "            return STATE_PAUSE;",
            "",
            "        case STATE_PAUSE:",
            "            // 这里可以添加暂停时的操作",
            "            return STATE_RESUME;",
            "",
            "        case STATE_RESUME:",
            "            // 这里可以添加恢复时的操作",
            "            return STATE_RUNNING;",
            "",
            "        case STATE_STOP:",
            "            // 这里可以添加停止时的操作",
            "            return STATE_IDLE;",
            "    }",
            "",
            "    // 默认情况下返回当前状态",
            "    return currentState;",
            "}"
        ],
        "description": "Code snippet for runStateMachine"
    },
    "removeNthFromEnd": {
        "prefix": "listRemoveNthFromEnd",
        "body": [
            "/**",
            " * Definition for singly-linked list.",
            " * struct ListNode {",
            " *     int val;",
            " *     struct ListNode *next;",
            " * };",
            " */",
            "",
            "struct ListNode *removeNthFromEnd(struct ListNode *head, int n) {",
            "    struct ListNode entry, *p_free, *p = head;",
            "    int i, sz = 0;",
            "    entry.next = head;",
            "    while (p != NULL) {",
            "        p = p->next;",
            "        sz++;",
            "    }",
            "    for (i = 0, p = &entry; i < sz - n; i++, p = p -> next)",
            "    ;",
            "    p_free = p->next;",
            "    if (n != 1) {",
            "        p->next = p->next->next;",
            "    } else {",
            "        p->next = NULL;",
            "    }",
            "    free(p_free);",
            "    return entry.next;",
            "}"
        ],
        "description": "Code snippet for listRemoveNthFromEnd"
    },
    "removeNthFromEndCn": {
        "prefix": "链表删除倒数第N个节点",
        "body": [
            "/**",
            " * Definition for singly-linked list.",
            " * struct ListNode {",
            " *     int val;",
            " *     struct ListNode *next;",
            " * };",
            " */",
            "",
            "struct ListNode *removeNthFromEnd(struct ListNode *head, int n) {",
            "    struct ListNode entry, *p_free, *p = head;",
            "    int i, sz = 0;",
            "    entry.next = head;",
            "    while (p != NULL) {",
            "        p = p->next;",
            "        sz++;",
            "    }",
            "    for (i = 0, p = &entry; i < sz - n; i++, p = p -> next)",
            "    ;",
            "    p_free = p->next;",
            "    if (n != 1) {",
            "        p->next = p->next->next;",
            "    } else {",
            "        p->next = NULL;",
            "    }",
            "    free(p_free);",
            "    return entry.next;",
            "}"
        ],
        "description": "Code snippet for listRemoveNthFromEnd"
    },
    "reverseBits": {
        "prefix": "reverseBits",
        "body": [
            "uint32_t reverseBits(uint32_t n)",
            "{",
            "    uint TotalBits = 32;",
            "    uint32_t reverse_int = 0;  // stored in memory as 32 bits, each bit valued 0",
            "    uint i;",
            "    for (i = 0; i < TotalBits; i++)",
            "    {",
            "        if ((n & (UINT32_C(1)",
            "                  << i)))  // if the bit on the ith position of 32 bit input is",
            "                           // 1, then proceed Further note the use of UINT32_C",
            "                           // to convert 1 to unsigned 32 bit int, since just 1",
            "                           // is treated as int which cannot be shifted left",
            "                           // more than 30 times",
            "            reverse_int =",
            "                reverse_int |",
            "                (UINT32_C(1)",
            "                 << (TotalBits - 1 -",
            "                     i));  // Convert the ith bit from the end in reverse_int",
            "                           // from 0 to 1, if ith bit from beginning in n is 1",
            "                           // This is achieved by using bitwise OR on",
            "                           // reverse_int (where ith bit from end is currently",
            "                           // 0) and 1 shifted left 31 - i bits (to ith bit from",
            "                           // the end)",
            "    }",
            "    return reverse_int;",
            "}"
        ],
        "description": "Code snippet for reverseBits"
    },
    "reverseBitsCN": {
        "prefix": "位反转uint32",
        "body": [
            "uint32_t reverseBits(uint32_t n)",
            "{",
            "    uint TotalBits = 32;",
            "    uint32_t reverse_int = 0;  // stored in memory as 32 bits, each bit valued 0",
            "    uint i;",
            "    for (i = 0; i < TotalBits; i++)",
            "    {",
            "        if ((n & (UINT32_C(1)",
            "                  << i)))  // if the bit on the ith position of 32 bit input is",
            "                           // 1, then proceed Further note the use of UINT32_C",
            "                           // to convert 1 to unsigned 32 bit int, since just 1",
            "                           // is treated as int which cannot be shifted left",
            "                           // more than 30 times",
            "            reverse_int =",
            "                reverse_int |",
            "                (UINT32_C(1)",
            "                 << (TotalBits - 1 -",
            "                     i));  // Convert the ith bit from the end in reverse_int",
            "                           // from 0 to 1, if ith bit from beginning in n is 1",
            "                           // This is achieved by using bitwise OR on",
            "                           // reverse_int (where ith bit from end is currently",
            "                           // 0) and 1 shifted left 31 - i bits (to ith bit from",
            "                           // the end)",
            "    }",
            "    return reverse_int;",
            "}"
        ],
        "description": "Code snippet for reverseBits"
    },
    "hammingWeight": {
        "prefix": "hammingWeight",
        "body": [
            "int hammingWeight(uint32_t n)",
            "{",
            "    int TotalBits = 32;",
            "    int i, weight = 0;",
            "    for (i = 0; i < TotalBits; i++)",
            "    {",
            "        if (n &",
            "            (UINT32_C(1)",
            "             << i))  // if the bit on the ith position of 32 bit input is 1,",
            "                     // then proceed Further note the use of UINT32_C to",
            "                     // convert 1 to unsigned 32 bit int, as just 1 is treated",
            "                     // as int which cannot be shifted left more than 30 times",
            "            weight += 1;",
            "    }",
            "    return weight;",
            "}"
        ],
        "description": "Code snippet for hammingWeight"
    },
    "hammingWeightCN": {
        "prefix": "求二进制1的个数",
        "body": [
            "int hammingWeight(uint32_t n)",
            "{",
            "    int TotalBits = 32;",
            "    int i, weight = 0;",
            "    for (i = 0; i < TotalBits; i++)",
            "    {",
            "        if (n &",
            "            (UINT32_C(1)",
            "             << i))  // if the bit on the ith position of 32 bit input is 1,",
            "                     // then proceed Further note the use of UINT32_C to",
            "                     // convert 1 to unsigned 32 bit int, as just 1 is treated",
            "                     // as int which cannot be shifted left more than 30 times",
            "            weight += 1;",
            "    }",
            "    return weight;",
            "}"
        ],
        "description": "Code snippet for hammingWeight"
    },
    "isValidBrackets": {
        "prefix": "isValidBrackets",
        "body": [
            "bool isValidBrackets(char *s)",
            "{",
            "    int i, k = 0, len = strlen(s);",
            "    char *store = calloc(len, sizeof(char));",
            "",
            "    for (i = 0; s[i] != 0; i++)",
            "    {",
            "        switch (s[i])",
            "        {",
            "        case '(':",
            "        case '{':",
            "        case '[':",
            "            store[k++] = s[i];",
            "            break;",
            "        case ')':",
            "            if (k < 1 || store[--k] != '(')",
            "                goto out;",
            "            break;",
            "        case '}':",
            "            if (k < 1 || store[--k] != '{')",
            "                goto out;",
            "            break;",
            "        case ']':",
            "            if (k < 1 || store[--k] != '[')",
            "                goto out;",
            "            break;",
            "        }",
            "    }",
            "out:",
            "    free(store);",
            "    return s[i] == '0' && k == 0;",
            "}"
        ],
        "description": "Code snippet for isValidBrackets"
    },
    "isValidBracketsCN": {
        "prefix": "检查括号配对",
        "body": [
            "bool isValidBrackets(char *s)",
            "{",
            "    int i, k = 0, len = strlen(s);",
            "    char *store = calloc(len, sizeof(char));",
            "",
            "    for (i = 0; s[i] != 0; i++)",
            "    {",
            "        switch (s[i])",
            "        {",
            "        case '(':",
            "        case '{':",
            "        case '[':",
            "            store[k++] = s[i];",
            "            break;",
            "        case ')':",
            "            if (k < 1 || store[--k] != '(')",
            "                goto out;",
            "            break;",
            "        case '}':",
            "            if (k < 1 || store[--k] != '{')",
            "                goto out;",
            "            break;",
            "        case ']':",
            "            if (k < 1 || store[--k] != '[')",
            "                goto out;",
            "            break;",
            "        }",
            "    }",
            "out:",
            "    free(store);",
            "    return s[i] == '0' && k == 0;",
            "}"
        ],
        "description": "Code snippet for isValidBrackets"
    },
    "rangeBitwiseAnd": {
        "prefix": "bitwiseAnd",
        "body": [
            "int rangeBitwiseAnd(int m, int n)",
            "{",
            "    while (m < n)",
            "    {",
            "        n &= n - 1;",
            "    }",
            "    return n;",
            "}"
        ],
        "description": "Code snippet for rangeBitwiseAnd statement"
    },
    "rangeBitwiseAndCN": {
        "prefix": "位与",
        "body": [
            "int rangeBitwiseAnd(int m, int n)",
            "{",
            "    while (m < n)",
            "    {",
            "        n &= n - 1;",
            "    }",
            "    return n;",
            "}"
        ],
        "description": "Code snippet for rangeBitwiseAndCN statement"
    },
    "listRemoveValElements": {
        "prefix": "listRemoveValElements",
        "body": [
            "struct ListNode *removeElements(struct ListNode *head, int val)",
            "{",
            "    if (head == NULL)",
            "        return NULL;",
            "    if (head->val == val)",
            "    {",
            "        return removeElements(head->next, val);",
            "    }",
            "    else",
            "    {",
            "        head->next = removeElements(head->next, val);",
            "    }",
            "    return head;",
            "}"
        ],
        "description": "Code snippet for listRemoveValElements statement"
    },
    "listRemoveValElementsCN": {
        "prefix": "链表删除给定值",
        "body": [
            "struct ListNode *removeElements(struct ListNode *head, int val)",
            "{",
            "    if (head == NULL)",
            "        return NULL;",
            "    if (head->val == val)",
            "    {",
            "        return removeElements(head->next, val);",
            "    }",
            "    else",
            "    {",
            "        head->next = removeElements(head->next, val);",
            "    }",
            "    return head;",
            "}"
        ],
        "description": "Code snippet for listRemoveValElements statement"
    },
    "listReverseList": {
        "prefix": "listReverseList",
        "body": [
            "/**",
            " * Definition for singly-linked list.",
            " * struct ListNode {",
            " *     int val;",
            " *     struct ListNode *next;",
            " * };",
            " */",
            "",
            "struct ListNode *reverseList(struct ListNode *head)",
            "{",
            "    struct ListNode *res = NULL;",
            "    while (head)",
            "    {",
            "        struct ListNode *pre_node = head;",
            "        head = head->next;",
            "        pre_node->next = res;",
            "        res = pre_node;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Code snippet for listReverseList statement"
    },
    "listReverseListCN": {
        "prefix": "链表反转",
        "body": [
            "/**",
            " * Definition for singly-linked list.",
            " * struct ListNode {",
            " *     int val;",
            " *     struct ListNode *next;",
            " * };",
            " */",
            "",
            "struct ListNode *reverseList(struct ListNode *head)",
            "{",
            "    struct ListNode *res = NULL;",
            "    while (head)",
            "    {",
            "        struct ListNode *pre_node = head;",
            "        head = head->next;",
            "        pre_node->next = res;",
            "        res = pre_node;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Code snippet for listReverseList statement"
    },
    "uniqueOccurrences": {
        "prefix": "arrUniqueOccurrences",
        "body": [
            "#define MAP_SIZE 2048",
            "",
            "int cmpvalue(const void *a, const void *b) { return *(int *)b - *(int *)a; }",
            "bool uniqueOccurrences(int *arr, int arrSize)",
            "{",
            "    int *map = calloc(MAP_SIZE, sizeof(int));",
            "    int i;",
            "    for (i = 0; i < arrSize; i++)",
            "    {",
            "        if (arr[i] < 0)",
            "            map[arr[i] + MAP_SIZE / 2] += 1;",
            "        else",
            "            map[arr[i]] += 1;",
            "    }",
            "    /* number of occurrences is sorted by decreasing order",
            "       Ex: 3 2 1 0 0 0 0 */",
            "    qsort(map, MAP_SIZE, sizeof(int), cmpvalue);",
            "    i = 0;",
            "    while (map[i])",
            "    {",
            "        if (map[i] == map[i + 1])",
            "            return 0;",
            "        i++;",
            "    }",
            "    return 1;",
            "}"
        ],
        "description": "Code snippet for uniqueOccurrences statement"
    },
    "uniqueOccurrencesCn": {
        "prefix": "数组元素是否唯一",
        "body": [
            "#define MAP_SIZE 2048",
            "",
            "int cmpvalue(const void *a, const void *b) { return *(int *)b - *(int *)a; }",
            "bool uniqueOccurrences(int *arr, int arrSize)",
            "{",
            "    int *map = calloc(MAP_SIZE, sizeof(int));",
            "    int i;",
            "    for (i = 0; i < arrSize; i++)",
            "    {",
            "        if (arr[i] < 0)",
            "            map[arr[i] + MAP_SIZE / 2] += 1;",
            "        else",
            "            map[arr[i]] += 1;",
            "    }",
            "    /* number of occurrences is sorted by decreasing order",
            "       Ex: 3 2 1 0 0 0 0 */",
            "    qsort(map, MAP_SIZE, sizeof(int), cmpvalue);",
            "    i = 0;",
            "    while (map[i])",
            "    {",
            "        if (map[i] == map[i + 1])",
            "            return 0;",
            "        i++;",
            "    }",
            "    return 1;",
            "}"
        ],
        "description": "Code snippet for uniqueOccurrences statement"
    },
    "MaxSubarray": {
        "prefix": "arrMaxSubarray",
        "body": [
            "int maxcmp(int a, int b) { return (a >= b) ? a : b; }",
            "",
            "/* max subarray problem by using Kadane's Algorithm",
            " */",
            "int maxProfit(int *prices, int pricesSize)",
            "{",
            "    /* maxCur: current maximum",
            "     * maxSoFar: found maximum for subarray so far",
            "     */",
            "    int maxCur = 0, maxSoFar = 0;",
            "    for (int i = 1; i < pricesSize; i++)",
            "    {",
            "        maxCur = maxcmp(0, maxCur + prices[i] - prices[i - 1]);",
            "        maxSoFar = maxcmp(maxSoFar, maxCur);",
            "    }",
            "    return maxSoFar;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "MaxSubarrayCn": {
        "prefix": "数组最大子数组和",
        "body": [
            "int maxcmp(int a, int b) { return (a >= b) ? a : b; }",
            "",
            "/* max subarray problem by using Kadane's Algorithm",
            " */",
            "int maxProfit(int *prices, int pricesSize)",
            "{",
            "    /* maxCur: current maximum",
            "     * maxSoFar: found maximum for subarray so far",
            "     */",
            "    int maxCur = 0, maxSoFar = 0;",
            "    for (int i = 1; i < pricesSize; i++)",
            "    {",
            "        maxCur = maxcmp(0, maxCur + prices[i] - prices[i - 1]);",
            "        maxSoFar = maxcmp(maxSoFar, maxCur);",
            "    }",
            "    return maxSoFar;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "isPalindrome": {
        "prefix": "strIsPalindrome",
        "body": [
            "bool isPalindrome(char *s)",
            "{",
            "    int start = 0, end = strlen(s) - 1;",
            "    while (start < end)",
            "    {",
            "        if (!isalpha(s[start]) && !isalnum(s[start]))",
            "        {",
            "            start++;",
            "        }",
            "        else if (!isalpha(s[end]) && !isalnum(s[end]))",
            "        {",
            "            end--;",
            "        }",
            "        else",
            "        {",
            "            char c1 = tolower(s[start]);",
            "            char c2 = tolower(s[end]);",
            "            if (c1 != c2)",
            "                return 0;",
            "            start++;",
            "            end--;",
            "        }",
            "    }",
            "    return 1;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "isPalindromeCN": {
        "prefix": "字符串回文判断",
        "body": [
            "bool isPalindrome(char *s)",
            "{",
            "    int start = 0, end = strlen(s) - 1;",
            "    while (start < end)",
            "    {",
            "        if (!isalpha(s[start]) && !isalnum(s[start]))",
            "        {",
            "            start++;",
            "        }",
            "        else if (!isalpha(s[end]) && !isalnum(s[end]))",
            "        {",
            "            end--;",
            "        }",
            "        else",
            "        {",
            "            char c1 = tolower(s[start]);",
            "            char c2 = tolower(s[end]);",
            "            if (c1 != c2)",
            "                return 0;",
            "            start++;",
            "            end--;",
            "        }",
            "    }",
            "    return 1;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "romanToInt": {
        "prefix": "strRomanToInt",
        "body": [
            "int romanToInt(char *s)",
            "{",
            "    int romanToInt = 0;",
            "    for (int i = 0; i < strlen(s); i++)",
            "    {",
            "        switch (s[i])",
            "        {",
            "        case 'I':",
            "            if (i + 1 < strlen(s))",
            "            {",
            "                if (s[i + 1] == 'V' || s[i + 1] == 'X')",
            "                {",
            "                    romanToInt -= 1;",
            "                    break;",
            "                }",
            "            }",
            "            romanToInt += 1;",
            "            break;",
            "        case 'V':",
            "            romanToInt += 5;",
            "            break;",
            "        case 'X':",
            "            if (i + 1 < strlen(s))",
            "            {",
            "                if (s[i + 1] == 'L' || s[i + 1] == 'C')",
            "                {",
            "                    romanToInt -= 10;",
            "                    break;",
            "                }",
            "            }",
            "            romanToInt += 10;",
            "            break;",
            "        case 'L':",
            "            romanToInt += 50;",
            "            break;",
            "        case 'C':",
            "            if (i + 1 < strlen(s))",
            "            {",
            "                if (s[i + 1] == 'D' || s[i + 1] == 'M')",
            "                {",
            "                    romanToInt -= 100;",
            "                    break;",
            "                }",
            "            }",
            "            romanToInt += 100;",
            "            break;",
            "        case 'D':",
            "            romanToInt += 500;",
            "            break;",
            "        case 'M':",
            "            romanToInt += 1000;",
            "            break;",
            "        default:",
            "            break;",
            "        }",
            "    }",
            "    return romanToInt;",
            "}"
        ],
        "description": "Code snippet for romanToInt statement"
    },
    "romanToIntCn": {
        "prefix": "字符串罗马数字转int",
        "body": [
            "int romanToInt(char *s)",
            "{",
            "    int romanToInt = 0;",
            "    for (int i = 0; i < strlen(s); i++)",
            "    {",
            "        switch (s[i])",
            "        {",
            "        case 'I':",
            "            if (i + 1 < strlen(s))",
            "            {",
            "                if (s[i + 1] == 'V' || s[i + 1] == 'X')",
            "                {",
            "                    romanToInt -= 1;",
            "                    break;",
            "                }",
            "            }",
            "            romanToInt += 1;",
            "            break;",
            "        case 'V':",
            "            romanToInt += 5;",
            "            break;",
            "        case 'X':",
            "            if (i + 1 < strlen(s))",
            "            {",
            "                if (s[i + 1] == 'L' || s[i + 1] == 'C')",
            "                {",
            "                    romanToInt -= 10;",
            "                    break;",
            "                }",
            "            }",
            "            romanToInt += 10;",
            "            break;",
            "        case 'L':",
            "            romanToInt += 50;",
            "            break;",
            "        case 'C':",
            "            if (i + 1 < strlen(s))",
            "            {",
            "                if (s[i + 1] == 'D' || s[i + 1] == 'M')",
            "                {",
            "                    romanToInt -= 100;",
            "                    break;",
            "                }",
            "            }",
            "            romanToInt += 100;",
            "            break;",
            "        case 'D':",
            "            romanToInt += 500;",
            "            break;",
            "        case 'M':",
            "            romanToInt += 1000;",
            "            break;",
            "        default:",
            "            break;",
            "        }",
            "    }",
            "    return romanToInt;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "singleNumber": {
        "prefix": "arrSingleNumber",
        "body": [
            "int singleNumber(int *nums, int numsSize)",
            "{",
            "    int i, result = 0;",
            "    for (i = 0; i < numsSize; i++)",
            "        result = result ^ nums[i];",
            "    return result;",
            "}"
        ],
        "description": "Code snippet for singleNumber statement"
    },
    "singleNumberCn": {
        "prefix": "数组只出现一次的数",
        "body": [
            "int singleNumber(int *nums, int numsSize)",
            "{",
            "    int i, result = 0;",
            "    for (i = 0; i < numsSize; i++)",
            "        result = result ^ nums[i];",
            "    return result;",
            "}"
        ],
        "description": "Code snippet for singleNumber statement"
    },
    "detectCycle": {
        "prefix": "listDetectCycle",
        "body": [
            "struct ListNode *detectCycle(struct ListNode *head)",
            "{",
            "    if (head == NULL || head->next == NULL)",
            "        return NULL;",
            "    struct ListNode *slow, *fast;",
            "    slow = fast = head;",
            "    while (fast && fast->next)",
            "    {",
            "        slow = slow->next;",
            "        fast = fast->next->next;",
            "        if (slow == fast)",
            "        {",
            "            struct ListNode *entry = head;",
            "            while (slow != entry)",
            "            {",
            "                slow = slow->next;",
            "                entry = entry->next;",
            "            }",
            "            return entry;",
            "        }",
            "    }",
            "    return NULL;",
            "}"
        ],
        "description": "Code snippet for listDetectCycle statement"
    },
    "detectCycleCn": {
        "prefix": "链表存在环",
        "body": [
            "struct ListNode *detectCycle(struct ListNode *head)",
            "{",
            "    if (head == NULL || head->next == NULL)",
            "        return NULL;",
            "    struct ListNode *slow, *fast;",
            "    slow = fast = head;",
            "    while (fast && fast->next)",
            "    {",
            "        slow = slow->next;",
            "        fast = fast->next->next;",
            "        if (slow == fast)",
            "        {",
            "            struct ListNode *entry = head;",
            "            while (slow != entry)",
            "            {",
            "                slow = slow->next;",
            "                entry = entry->next;",
            "            }",
            "            return entry;",
            "        }",
            "    }",
            "    return NULL;",
            "}"
        ],
        "description": "Code snippet for listDetectCycle statement"
    },
    "find2divideMin": {
        "prefix": "arr2divideFindMin",
        "body": [
            "int findMin(int *nums, int numsSize)",
            "{",
            "    int low = 0, high = numsSize - 1;",
            "    while (low < high)",
            "    {",
            "        int mid = low + (high - low) / 2;",
            "        /* minimum is on left side */",
            "        if (nums[mid] < nums[high])",
            "            high = mid;",
            "        /* minimum is on right side */",
            "        else",
            "            low = mid + 1;",
            "    }",
            "    return nums[low];",
            "}"
        ],
        "description": "Code snippet for arrFind2divideMin statement"
    },
    "find2divideMinCn": {
        "prefix": "数组二分法查找最小值",
        "body": [
            "int findMin(int *nums, int numsSize)",
            "{",
            "    int low = 0, high = numsSize - 1;",
            "    while (low < high)",
            "    {",
            "        int mid = low + (high - low) / 2;",
            "        /* minimum is on left side */",
            "        if (nums[mid] < nums[high])",
            "            high = mid;",
            "        /* minimum is on right side */",
            "        else",
            "            low = mid + 1;",
            "    }",
            "    return nums[low];",
            "}"
        ],
        "description": "Code snippet for arrFind2divideMin statement"
    },
    "threeSumClosest": {
        "prefix": "arrThreeSumClosest",
        "body": [
            "#include <stdlib.h> // for qsort()",
            "",
            "int cmp(const void* a, const void* b) {",
            "    const int *A = a, *B = b;",
            "    return (*A > *B) - (*A < *B);",
            "}",
            "",
            "int threeSumClosest(int* nums, int nums_size, int target) {",
            "    int i, j, k, result, sum3;",
            "    qsort(nums, nums_size, sizeof(int), cmp);",
            "    result = nums[0] + nums[1] + nums[2];",
            "    for (i = 0; i < nums_size - 2; i++) {",
            "        j = i + 1;",
            "        k = nums_size - 1;",
            "        while (j < k) {",
            "            sum3 = nums[i] + nums[j] + nums[k];",
            "            if (abs(target - sum3) < abs(target - result)) {",
            "                result = sum3;",
            "            }",
            "            if (sum3 < target) {",
            "                j++;",
            "            } else if (sum3 > target) {",
            "                k--;",
            "            } else {",
            "                return sum3;",
            "            }",
            "        }",
            "    }",
            "    return result;",
            "}"
        ],
        "description": "Code snippet for arrThreeSumClosest statement"
    },
    "threeSumClosestCn": {
        "prefix": "数组最接近目标的值",
        "body": [
            "#include <stdlib.h> // for qsort()",
            "",
            "int cmp(const void* a, const void* b) {",
            "    const int *A = a, *B = b;",
            "    return (*A > *B) - (*A < *B);",
            "}",
            "",
            "int threeSumClosest(int* nums, int nums_size, int target) {",
            "    int i, j, k, result, sum3;",
            "    qsort(nums, nums_size, sizeof(int), cmp);",
            "    result = nums[0] + nums[1] + nums[2];",
            "    for (i = 0; i < nums_size - 2; i++) {",
            "        j = i + 1;",
            "        k = nums_size - 1;",
            "        while (j < k) {",
            "            sum3 = nums[i] + nums[j] + nums[k];",
            "            if (abs(target - sum3) < abs(target - result)) {",
            "                result = sum3;",
            "            }",
            "            if (sum3 < target) {",
            "                j++;",
            "            } else if (sum3 > target) {",
            "                k--;",
            "            } else {",
            "                return sum3;",
            "            }",
            "        }",
            "    }",
            "    return result;",
            "}"
        ],
        "description": "Code snippet for arrThreeSumClosest statement"
    },
    "performFFT": {
        "prefix": "performFFT",
        "body": [
            "#include <fftw3.h>",
            "",
            "void performFFT(double* signal, int signalLength) {",
            "    fftw_complex* output;",
            "    fftw_plan plan;",
            "",
            "    // 分配傅里叶变换输出数组",
            "    output = (fftw_complex*)fftw_malloc(sizeof(fftw_complex) * signalLength);",
            "",
            "    // 创建傅里叶变换计划",
            "    plan = fftw_plan_dft_r2c_1d(signalLength, signal, output, FFTW_ESTIMATE);",
            "",
            "    // 执行傅里叶变换",
            "    fftw_execute(plan);",
            "",
            "    // 输出变换结果",
            "    for (int i = 0; i < signalLength; i++) {",
            "        printf",
            "    }",
            "",
            "    // 清理资源",
            "    fftw_destroy_plan(plan);",
            "    fftw_free(output);",
            "}"
        ],
        "description": "Code snippet for performFFT statement"
    },
    "performFFT": {
        "prefix": "傅里叶变换",
        "body": [
            "#include <fftw3.h>",
            "",
            "void performFFT(double* signal, int signalLength) {",
            "    fftw_complex* output;",
            "    fftw_plan plan;",
            "",
            "    // 分配傅里叶变换输出数组",
            "    output = (fftw_complex*)fftw_malloc(sizeof(fftw_complex) * signalLength);",
            "",
            "    // 创建傅里叶变换计划",
            "    plan = fftw_plan_dft_r2c_1d(signalLength, signal, output, FFTW_ESTIMATE);",
            "",
            "    // 执行傅里叶变换",
            "    fftw_execute(plan);",
            "",
            "    // 输出变换结果",
            "    for (int i = 0; i < signalLength; i++) {",
            "        printf",
            "    }",
            "",
            "    // 清理资源",
            "    fftw_destroy_plan(plan);",
            "    fftw_free(output);",
            "}"
        ],
        "description": "Code snippet for performFFT statement"
    },
    "KalmanFilter": {
        "prefix": "KalmanFilter",
        "body": [
            "#include <stdio.h>",
            "",
            "// 卡尔曼滤波器结构体",
            "typedef struct {",
            "    double x;  // 状态变量的估计",
            "    double P;  // 估计误差的协方差",
            "    double Q;  // 状态预测噪声的协方差",
            "    double R;  // 测量噪声的协方差",
            "} KalmanFilter;",
            "",
            "// 初始化卡尔曼滤波器",
            "void initKalmanFilter(KalmanFilter *kf, double initialX, double initialP, double processNoise, double measurementNoise) {",
            "    kf->x = initialX;",
            "    kf->P = initialP;",
            "    kf->Q = processNoise;",
            "    kf->R = measurementNoise;",
            "}",
            "",
            "// 更新卡尔曼滤波器",
            "void updateKalmanFilter(KalmanFilter *kf, double measurement) {",
            "    // 预测步骤",
            "    double x_pred = kf->x;",
            "    double P_pred = kf->P + kf->Q;",
            "",
            "    // 更新步骤",
            "    double K = P_pred / (P_pred + kf->R);",
            "    kf->x = x_pred + K * (measurement - x_pred);",
            "    kf->P = (1 - K) * P_pred;",
            "}",
            "",
            "int main() {",
            "    KalmanFilter kf;",
            "    double initialX = 0.0;",
            "    double initialP = 1.0;",
            "    double processNoise = 0.01;",
            "    double measurementNoise = 0.1;",
            "",
            "    // 初始化卡尔曼滤波器",
            "    initKalmanFilter(&kf, initialX, initialP, processNoise, measurementNoise);",
            "",
            "    // 模拟测量值",
            "    double measurements[] = {1.1, 1.2, 1.3, 1.4, 1.5};",
            "",
            "    for (int i = 0; i < sizeof(measurements) / sizeof(measurements[0]); i++) {",
            "        // 更新卡尔曼滤波器",
            "        updateKalmanFilter(&kf, measurements[i]);",
            "        printf",
            "    }",
            "",
            "    return 0;",
            "}",
            "在上面的示例中，我们首先定义了一个 KalmanFilter 结构体，该结构体包含卡尔曼滤波器的状态变量和参数。然后，我们编写了初始化和更新卡尔曼滤波器的函数，并在 main 函数中使用这些函数来执行卡尔曼滤波。卡尔曼滤波器的核心思想在于预测和更新步骤，其中预测步骤用于估计下一个状态，而更新步骤用于根据测量值来调整估计。这个示例是一个简单的一维线性卡尔曼滤波器，用于估计一维状态变量。",
            "",
            "",
            "",
            "",
            ""
        ],
        "description": "Code snippet for switch statement"
    },
    "KalmanFilter": {
        "prefix": "卡尔曼滤波器",
        "body": [
            "#include <stdio.h>",
            "",
            "// 卡尔曼滤波器结构体",
            "typedef struct {",
            "    double x;  // 状态变量的估计",
            "    double P;  // 估计误差的协方差",
            "    double Q;  // 状态预测噪声的协方差",
            "    double R;  // 测量噪声的协方差",
            "} KalmanFilter;",
            "",
            "// 初始化卡尔曼滤波器",
            "void initKalmanFilter(KalmanFilter *kf, double initialX, double initialP, double processNoise, double measurementNoise) {",
            "    kf->x = initialX;",
            "    kf->P = initialP;",
            "    kf->Q = processNoise;",
            "    kf->R = measurementNoise;",
            "}",
            "",
            "// 更新卡尔曼滤波器",
            "void updateKalmanFilter(KalmanFilter *kf, double measurement) {",
            "    // 预测步骤",
            "    double x_pred = kf->x;",
            "    double P_pred = kf->P + kf->Q;",
            "",
            "    // 更新步骤",
            "    double K = P_pred / (P_pred + kf->R);",
            "    kf->x = x_pred + K * (measurement - x_pred);",
            "    kf->P = (1 - K) * P_pred;",
            "}",
            "",
            "int main() {",
            "    KalmanFilter kf;",
            "    double initialX = 0.0;",
            "    double initialP = 1.0;",
            "    double processNoise = 0.01;",
            "    double measurementNoise = 0.1;",
            "",
            "    // 初始化卡尔曼滤波器",
            "    initKalmanFilter(&kf, initialX, initialP, processNoise, measurementNoise);",
            "",
            "    // 模拟测量值",
            "    double measurements[] = {1.1, 1.2, 1.3, 1.4, 1.5};",
            "",
            "    for (int i = 0; i < sizeof(measurements) / sizeof(measurements[0]); i++) {",
            "        // 更新卡尔曼滤波器",
            "        updateKalmanFilter(&kf, measurements[i]);",
            "        printf",
            "    }",
            "",
            "    return 0;",
            "}",
            "在上面的示例中，我们首先定义了一个 KalmanFilter 结构体，该结构体包含卡尔曼滤波器的状态变量和参数。然后，我们编写了初始化和更新卡尔曼滤波器的函数，并在 main 函数中使用这些函数来执行卡尔曼滤波。卡尔曼滤波器的核心思想在于预测和更新步骤，其中预测步骤用于估计下一个状态，而更新步骤用于根据测量值来调整估计。这个示例是一个简单的一维线性卡尔曼滤波器，用于估计一维状态变量。",
            "",
            "",
            "",
            "",
            ""
        ],
        "description": "Code snippet for switch statement"
    },
    "majorityElement": {
        "prefix": "arrMajorityElement",
        "body": [
            "/* Boyer-Moore Majority Vote Algorithm",
            " * http://www.cs.utexas.edu/~moore/best-ideas/mjrty/ */",
            "int majorityElement(int *nums, int numsSize)",
            "{",
            "    int count = 1;",
            "    int majorNum = nums[0];",
            "    for (int i = 1; i < numsSize; i++)",
            "    {",
            "        if (count == 0)",
            "        {",
            "            majorNum = nums[i];",
            "            count++;",
            "        }",
            "        else if (majorNum == nums[i])",
            "            count++;",
            "        else",
            "            count--;",
            "    }",
            "    return majorNum;",
            "}"
        ],
        "description": "Code snippet for arrMajorityElement statement"
    },
    "majorityElementCn": {
        "prefix": "数组多数投票算法",
        "body": [
            "/* Boyer-Moore Majority Vote Algorithm",
            " * http://www.cs.utexas.edu/~moore/best-ideas/mjrty/ */",
            "int majorityElement(int *nums, int numsSize)",
            "{",
            "    int count = 1;",
            "    int majorNum = nums[0];",
            "    for (int i = 1; i < numsSize; i++)",
            "    {",
            "        if (count == 0)",
            "        {",
            "            majorNum = nums[i];",
            "            count++;",
            "        }",
            "        else if (majorNum == nums[i])",
            "            count++;",
            "        else",
            "            count--;",
            "    }",
            "    return majorNum;",
            "}"
        ],
        "description": "Code snippet for arrMajorityElement statement"
    },
    "arrMaximumUniqueSubarray": {
        "prefix": "arrMaximumUniqueSubarray",
        "body": [
            "/ Window sliding. Runtime: O(n), Space: O(n)",
            "int maximumUniqueSubarray(int* nums, int numsSize){",
            "    short* numsSet = (short*)calloc(10001, sizeof(short));",
            "    numsSet[nums[0]] = 1;",
            "",
            "    int maxSum = nums[0];",
            "",
            "    int windowSumm = maxSum;",
            "    int leftIndex = 0;",
            "    ",
            "    int num = 0;",
            "    for(int i = 1; i < numsSize; i++){",
            "        num = nums[i];",
            "        while (numsSet[num] != 0){",
            "            numsSet[nums[leftIndex]] = 0;",
            "            windowSumm -= nums[leftIndex];",
            "            leftIndex++;",
            "        }",
            "        ",
            "        numsSet[num] = 1;",
            "        windowSumm += num;",
            "            ",
            "        if (maxSum < windowSumm){",
            "            maxSum = windowSumm;",
            "        }",
            "    }",
            "    ",
            "    return maxSum;",
            "}"
        ],
        "description": "Code snippet for arrMaximumUniqueSubarray statement"
    },
    "arrMaximumUniqueSubarrayCn": {
        "prefix": "数组查找数组中的具有最大唯一元素和的子数组",
        "body": [
            "/ 窗口滑动.Window sliding. Runtime: O(n), Space: O(n)",
            "int maximumUniqueSubarray(int* nums, int numsSize){",
            "    short* numsSet = (short*)calloc(10001, sizeof(short));",
            "    numsSet[nums[0]] = 1;",
            "",
            "    int maxSum = nums[0];",
            "",
            "    int windowSumm = maxSum;",
            "    int leftIndex = 0;",
            "    ",
            "    int num = 0;",
            "    for(int i = 1; i < numsSize; i++){",
            "        num = nums[i];",
            "        while (numsSet[num] != 0){",
            "            numsSet[nums[leftIndex]] = 0;",
            "            windowSumm -= nums[leftIndex];",
            "            leftIndex++;",
            "        }",
            "        ",
            "        numsSet[num] = 1;",
            "        windowSumm += num;",
            "            ",
            "        if (maxSum < windowSumm){",
            "            maxSum = windowSumm;",
            "        }",
            "    }",
            "    ",
            "    return maxSum;",
            "}"
        ],
        "description": "Code snippet for arrMaximumUniqueSubarray statement"
    },
    "strHalvesAreAlike": {
        "prefix": "strHalvesAreAlike",
        "body": [
            "bool isVowel(char chr){",
            "    switch(chr){",
            "        case 'a':",
            "        case 'e':",
            "        case 'i':",
            "        case 'o':",
            "        case 'u':",
            "        case 'A':",
            "        case 'E':",
            "        case 'I':",
            "        case 'O':",
            "        case 'U':",
            "            return true;",
            "    }",
            "    ",
            "    return false;",
            "}",
            "",
            "// Counting",
            "// Runtime: O(n)",
            "// Space: O(1)",
            "bool halvesAreAlike(char * s){",
            "    int lenS = strlen(s);",
            "    int halfVowels = 0;",
            "    int currVowels = 0;",
            "    ",
            "    for (int i = 0; i < lenS; i++){",
            "        if (isVowel(s[i])){",
            "            currVowels++;",
            "        }",
            "        ",
            "        if (2 * (i + 1) == lenS){",
            "            halfVowels = currVowels;",
            "        }",
            "    }",
            "    ",
            "    return 2 * halfVowels == currVowels;",
            "}"
        ],
        "description": "Code snippet for strHalvesAreAlike statement"
    },
    "strHalvesAreAlike": {
        "prefix": "字符串前半部分和后半部分是否包含相同数量的元素",
        "body": [
            "bool isVowel(char chr){",
            "    switch(chr){",
            "        case 'a':",
            "        case 'e':",
            "        case 'i':",
            "        case 'o':",
            "        case 'u':",
            "        case 'A':",
            "        case 'E':",
            "        case 'I':",
            "        case 'O':",
            "        case 'U':",
            "            return true;",
            "    }",
            "    ",
            "    return false;",
            "}",
            "",
            "// Counting",
            "// Runtime: O(n)",
            "// Space: O(1)",
            "bool halvesAreAlike(char * s){",
            "    int lenS = strlen(s);",
            "    int halfVowels = 0;",
            "    int currVowels = 0;",
            "    ",
            "    for (int i = 0; i < lenS; i++){",
            "        if (isVowel(s[i])){",
            "            currVowels++;",
            "        }",
            "        ",
            "        if (2 * (i + 1) == lenS){",
            "            halfVowels = currVowels;",
            "        }",
            "    }",
            "    ",
            "    return 2 * halfVowels == currVowels;",
            "}"
        ],
        "description": "Code snippet for strHalvesAreAlike statement"
    },
    "bSTIterator": {
        "prefix": "bSTIterator",
        "body": [
            "#include <limits.h>",
            "//O(1)",
            "typedef struct",
            "{",
            "    int *values;",
            "    int CurrentIndex;",
            "    int NumberOfNodes;",
            "} BSTIterator;",
            "",
            "void TraverseAndAssign(struct TreeNode *root, BSTIterator *obj)",
            "{",
            "    if (!root)",
            "        return;",
            "    if (root->left)",
            "        TraverseAndAssign(root->left, obj);",
            "    obj->values[obj->CurrentIndex] = root->val;",
            "    obj->CurrentIndex++;",
            "    if (root->right)",
            "        TraverseAndAssign(root->right, obj);",
            "}",
            "",
            "int TotalNodes(struct TreeNode *root)",
            "{",
            "    if (!root)",
            "        return 0;",
            "    int nodes_left = TotalNodes(root->left);",
            "    int nodes_right = TotalNodes(root->right);",
            "    return nodes_left + nodes_right + 1;",
            "}",
            "",
            "BSTIterator *bSTIteratorCreate(struct TreeNode *root)",
            "{",
            "    int n = TotalNodes(root);",
            "    int size = n + 1;",
            "    printf(%d, size);",
            "    BSTIterator *obj = (BSTIterator *)malloc(sizeof(BSTIterator));",
            "    obj->values = (int *)calloc(size, sizeof(int));",
            "    obj->CurrentIndex = 0;",
            "    obj->NumberOfNodes = n;",
            "    obj->values[size - 1] = INT_MAX;",
            "    TraverseAndAssign(root, obj);",
            "    obj->CurrentIndex = 0;",
            "    return obj;",
            "}",
            "",
            "/** @return the next smallest number */",
            "int bSTIteratorNext(BSTIterator *obj)",
            "{",
            "    int NextValue = obj->values[obj->CurrentIndex];",
            "    obj->CurrentIndex++;",
            "    return NextValue;",
            "}",
            "",
            "/** @return whether we have a next smallest number */",
            "bool bSTIteratorHasNext(BSTIterator *obj)",
            "{",
            "    if (!obj->NumberOfNodes)",
            "    {",
            "        return false;",
            "    }",
            "    printf();",
            "    return (obj->values[obj->CurrentIndex] == INT_MAX) ? false : true;",
            "}",
            "",
            "void bSTIteratorFree(BSTIterator *obj)",
            "{",
            "    free(obj->values);",
            "    free(obj);",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "bSTIteratorCn": {
        "prefix": "二叉搜索树迭代升序遍历",
        "body": [
            "#include <limits.h>",
            "//O(1)",
            "typedef struct",
            "{",
            "    int *values;",
            "    int CurrentIndex;",
            "    int NumberOfNodes;",
            "} BSTIterator;",
            "",
            "void TraverseAndAssign(struct TreeNode *root, BSTIterator *obj)",
            "{",
            "    if (!root)",
            "        return;",
            "    if (root->left)",
            "        TraverseAndAssign(root->left, obj);",
            "    obj->values[obj->CurrentIndex] = root->val;",
            "    obj->CurrentIndex++;",
            "    if (root->right)",
            "        TraverseAndAssign(root->right, obj);",
            "}",
            "",
            "int TotalNodes(struct TreeNode *root)",
            "{",
            "    if (!root)",
            "        return 0;",
            "    int nodes_left = TotalNodes(root->left);",
            "    int nodes_right = TotalNodes(root->right);",
            "    return nodes_left + nodes_right + 1;",
            "}",
            "",
            "BSTIterator *bSTIteratorCreate(struct TreeNode *root)",
            "{",
            "    int n = TotalNodes(root);",
            "    int size = n + 1;",
            "    printf(%d, size);",
            "    BSTIterator *obj = (BSTIterator *)malloc(sizeof(BSTIterator));",
            "    obj->values = (int *)calloc(size, sizeof(int));",
            "    obj->CurrentIndex = 0;",
            "    obj->NumberOfNodes = n;",
            "    obj->values[size - 1] = INT_MAX;",
            "    TraverseAndAssign(root, obj);",
            "    obj->CurrentIndex = 0;",
            "    return obj;",
            "}",
            "",
            "/** @return the next smallest number */",
            "int bSTIteratorNext(BSTIterator *obj)",
            "{",
            "    int NextValue = obj->values[obj->CurrentIndex];",
            "    obj->CurrentIndex++;",
            "    return NextValue;",
            "}",
            "",
            "/** @return whether we have a next smallest number */",
            "bool bSTIteratorHasNext(BSTIterator *obj)",
            "{",
            "    if (!obj->NumberOfNodes)",
            "    {",
            "        return false;",
            "    }",
            "    printf();",
            "    return (obj->values[obj->CurrentIndex] == INT_MAX) ? false : true;",
            "}",
            "",
            "void bSTIteratorFree(BSTIterator *obj)",
            "{",
            "    free(obj->values);",
            "    free(obj);",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "algoMaxIceCream": {
        "prefix": "algoMaxIceCream",
        "body": [
            "int compare(const void* i, const void* j)",
            "{",
            "    return *((int*)i) - *((int*)j);",
            "}",
            "",
            "// Greedy + sorting",
            "// Runtime: O(n*log(n))",
            "// Space: O(1)",
            "int maxIceCream(int* costs, int costsSize, int coins){",
            "    qsort(costs, costsSize, sizeof(int), compare);",
            "",
            "    int result = 0;",
            "    int leftCoins = coins;",
            "    for (int i = 0; i < costsSize; i++){",
            "        if (costs[i] > leftCoins){",
            "            break;",
            "        }",
            "",
            "        leftCoins -= costs[i];",
            "        result++;",
            "    }",
            "",
            "    return result;",
            "}"
        ],
        "description": "The idea behind this greedy algorithm is to buy the cheapest ice cream possible to maximize the quantity purchased."
    },
    "algoMaxIceCream": {
        "prefix": "算法贪心算法",
        "body": [
            "//这个贪心算法的思路是尽可能购买最便宜的冰淇淋，以最大化购买的数量。""int compare(const void* i, const void* j)",
            "{",
            "    return *((int*)i) - *((int*)j);",
            "}",
            "",
            "// Greedy + sorting",
            "// Runtime: O(n*log(n))",
            "// Space: O(1)",
            "int maxIceCream(int* costs, int costsSize, int coins){",
            "    qsort(costs, costsSize, sizeof(int), compare);",
            "",
            "    int result = 0;",
            "    int leftCoins = coins;",
            "    for (int i = 0; i < costsSize; i++){",
            "        if (costs[i] > leftCoins){",
            "            break;",
            "        }",
            "",
            "        leftCoins -= costs[i];",
            "        result++;",
            "    }",
            "",
            "    return result;",
            "}"
        ],
        "description": "The idea behind this greedy algorithm is to buy the cheapest ice cream possible to maximize the quantity purchased."
    },
    "arrContainsDuplicate": {
        "prefix": "arrContainsDuplicate",
        "body": [
            "int numcmp(const void *a, const void *b) { return *(int *)a - *(int *)b; }",
            "//O(n * log(n))",
            "bool containsDuplicate(int *nums, int numsSize)",
            "{",
            "    int i;",
            "    qsort(nums, numsSize, sizeof(int), numcmp);",
            "    for (i = 0; i < numsSize - 1; i++)",
            "    {",
            "        if (nums[i] == nums[i + 1])",
            "            return 1;",
            "    }",
            "    return 0;",
            "}"
        ],
        "description": "Code snippet for arrContainsDuplicate statement"
    },
    "arrContainsDuplicateCn": {
        "prefix": "数组是否包含重复元素",
        "body": [
            "int numcmp(const void *a, const void *b) { return *(int *)a - *(int *)b; }",
            "//O(n * log(n))",
            "bool containsDuplicate(int *nums, int numsSize)",
            "{",
            "    int i;",
            "    qsort(nums, numsSize, sizeof(int), numcmp);",
            "    for (i = 0; i < numsSize - 1; i++)",
            "    {",
            "        if (nums[i] == nums[i + 1])",
            "            return 1;",
            "    }",
            "    return 0;",
            "}"
        ],
        "description": "Code snippet for arrContainsDuplicate statement"
    },
    "algoMaximumBags": {
        "prefix": "algoMaximumBags",
        "body": [
            "int compare(const int* i, const int* j)",
            "{",
            "    return *i - *j;",
            "}",
            "//The goal of this code is to calculate, given a set of backpack capacities (capacity) and a set of rock masses (rocks), the maximum number of bags of rocks that can be loaded to satisfy the capacity limit of each backpack.",
            "// Sorting.",
            "// Runtime: O(n*log(n))",
            "// Space: O(n)",
            "int maximumBags(int* capacity, int capacitySize, int* rocks, int rocksSize, int additionalRocks) {",
            "    int* capacityLeft = malloc(capacitySize * sizeof(int));",
            "    for (int i = 0; i < capacitySize; i++) {",
            "        capacityLeft[i] = capacity[i] - rocks[i];",
            "    }",
            "",
            "    qsort(capacityLeft, capacitySize, sizeof (int), (int(*) (const void*, const void*)) compare);",
            "    ",
            "    int bags = 0;",
            "    for (int i = 0; i < capacitySize; i++) {",
            "        if (additionalRocks < capacityLeft[i]){",
            "            break;",
            "        }",
            "",
            "        additionalRocks -= capacityLeft[i];",
            "        bags++;",
            "    }",
            "",
            "    free(capacityLeft);",
            "    return bags;",
            "}"
        ],
        "description": "Code snippet for algoMaximumBags statement"
    },
    "algoMaximumBagsCn": {
        "prefix": "算法背包的容量限制",
        "body": [
            "int compare(const int* i, const int* j)",
            "{",
            "    return *i - *j;",
            "}",
            "//这段代码的目标是计算在给定一组背包容量（capacity）和一组岩石质量（rocks）的情况下，最多可以装多少袋岩石，以满足每个背包的容量限制。",
            "// Sorting.",
            "// Runtime: O(n*log(n))",
            "// Space: O(n)",
            "int maximumBags(int* capacity, int capacitySize, int* rocks, int rocksSize, int additionalRocks) {",
            "    int* capacityLeft = malloc(capacitySize * sizeof(int));",
            "    for (int i = 0; i < capacitySize; i++) {",
            "        capacityLeft[i] = capacity[i] - rocks[i];",
            "    }",
            "",
            "    qsort(capacityLeft, capacitySize, sizeof (int), (int(*) (const void*, const void*)) compare);",
            "    ",
            "    int bags = 0;",
            "    for (int i = 0; i < capacitySize; i++) {",
            "        if (additionalRocks < capacityLeft[i]){",
            "            break;",
            "        }",
            "",
            "        additionalRocks -= capacityLeft[i];",
            "        bags++;",
            "    }",
            "",
            "    free(capacityLeft);",
            "    return bags;",
            "}"
        ],
        "description": "Code snippet for algoMaximumBags statement"
    },
    "algominPathCost": {
        "prefix": "algominPathCost",
        "body": [
            "#define min(x,y)(((x)<(y))?(x):(y))",
            "//The goal of this code is to calculate the minimum path cost from the upper left corner to the lower right corner in a grid. Among them, the grid contains different movement costs, and each grid has a specific cost.",
            "// DP up -> down. We are going down from gridline to gridline",
            "// and collect the minumum cost path.",
            "// Runtime : O(gridSize*gridColSize*gridColSize)",
            "// Space: O(gridColSize)",
            "int minPathCost(int** grid, int gridSize, int* gridColSize, int** moveCost, int moveCostSize, int* moveCostColSize){",
            "    int* dp = (int*)calloc(gridColSize[0], sizeof(int));",
            "    int* newDp = (int*)calloc(gridColSize[0], sizeof(int));",
            "    ",
            "    for(int i = 0; i < gridSize - 1; i++){",
            "        int currGridColSize = gridColSize[i];",
            "        for(int j = 0; j < currGridColSize; j++){",
            "            newDp[j] = -1;",
            "        }",
            "        ",
            "        for(int j = 0; j < currGridColSize; j++){",
            "            int currGridItem = grid[i][j];",
            "            for(int z = 0; z < currGridColSize; z++){",
            "                int currMoveCost = dp[j] + moveCost[currGridItem][z] + currGridItem;",
            "                ",
            "                newDp[z] = (newDp[z] == -1) ? currMoveCost : min(newDp[z], currMoveCost);",
            "            }",
            "        }",
            "        ",
            "        for(int j = 0; j < currGridColSize; j++){",
            "            dp[j] = newDp[j];",
            "        }",
            "    }",
            "    ",
            "    // Find minimum value.",
            "    int minValue = dp[0] + grid[gridSize - 1][0];",
            "    for(int j = 1; j < gridColSize[0]; j++){",
            "        minValue = min(minValue, dp[j] + grid[gridSize - 1][j]);",
            "    }",
            "    ",
            "    // free resources",
            "    free(dp);",
            "    free(newDp);",
            "    ",
            "    return minValue;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "algominPathCostcN": {
        "prefix": "算法最短路径成本",
        "body": [
            "#define min(x,y)(((x)<(y))?(x):(y))",
            "//The goal of this code is to calculate the minimum path cost from the upper left corner to the lower right corner in a grid. Among them, the grid contains different movement costs, and each grid has a specific cost.",
            "// DP up -> down. We are going down from gridline to gridline",
            "// and collect the minumum cost path.",
            "// Runtime : O(gridSize*gridColSize*gridColSize)",
            "// Space: O(gridColSize)",
            "int minPathCost(int** grid, int gridSize, int* gridColSize, int** moveCost, int moveCostSize, int* moveCostColSize){",
            "    int* dp = (int*)calloc(gridColSize[0], sizeof(int));",
            "    int* newDp = (int*)calloc(gridColSize[0], sizeof(int));",
            "    ",
            "    for(int i = 0; i < gridSize - 1; i++){",
            "        int currGridColSize = gridColSize[i];",
            "        for(int j = 0; j < currGridColSize; j++){",
            "            newDp[j] = -1;",
            "        }",
            "        ",
            "        for(int j = 0; j < currGridColSize; j++){",
            "            int currGridItem = grid[i][j];",
            "            for(int z = 0; z < currGridColSize; z++){",
            "                int currMoveCost = dp[j] + moveCost[currGridItem][z] + currGridItem;",
            "                ",
            "                newDp[z] = (newDp[z] == -1) ? currMoveCost : min(newDp[z], currMoveCost);",
            "            }",
            "        }",
            "        ",
            "        for(int j = 0; j < currGridColSize; j++){",
            "            dp[j] = newDp[j];",
            "        }",
            "    }",
            "    ",
            "    // Find minimum value.",
            "    int minValue = dp[0] + grid[gridSize - 1][0];",
            "    for(int j = 1; j < gridColSize[0]; j++){",
            "        minValue = min(minValue, dp[j] + grid[gridSize - 1][j]);",
            "    }",
            "    ",
            "    // free resources",
            "    free(dp);",
            "    free(newDp);",
            "    ",
            "    return minValue;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "isPowerOfTwo": {
        "prefix": "algoisPowerOfTwo",
        "body": [
            "bool isPowerOfTwo(int n){",
            "    return (n > 0) && ((n & (n - 1)) == 0);",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "isPowerOfTwocn": {
        "prefix": "算法是否是2的幂",
        "body": [
            "bool isPowerOfTwo(int n){",
            "    return (n > 0) && ((n & (n - 1)) == 0);",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "isAnagram": {
        "prefix": "isAnagram",
        "body": [
            "This code checks whether two strings s and t are anagrams. An anagram is when two strings contain the same characters, just in a different order.",
            "bool isAnagram(char *s, char *t)",
            "{",
            "    int n = strlen(s);",
            "    int m = strlen(t);",
            "",
            "    int cnt_s[1000], cnt_t[1000];",
            "    for (int c = 97; c < 97 + 26; c++) cnt_s[c] = cnt_t[c] = 0;",
            "",
            "    for (int i = 0; i < n; i++) cnt_s[s[i]]++;",
            "",
            "    for (int i = 0; i < m; i++) cnt_t[t[i]]++;",
            "",
            "    for (int c = 97; c < 97 + 26; c++)",
            "        if (cnt_s[c] != cnt_t[c])",
            "            return false;",
            "",
            "    return true;",
            "}"
        ],
        "description": "Code snippet for isAnagram statement"
    },
    "isAnagramCn": {
        "prefix": "算法字母异位词",
        "body": [
            "This code checks whether two strings s and t are anagrams. An anagram is when two strings contain the same characters, just in a different order.",
            "bool isAnagram(char *s, char *t)",
            "{",
            "    int n = strlen(s);",
            "    int m = strlen(t);",
            "",
            "    int cnt_s[1000], cnt_t[1000];",
            "    for (int c = 97; c < 97 + 26; c++) cnt_s[c] = cnt_t[c] = 0;",
            "",
            "    for (int i = 0; i < n; i++) cnt_s[s[i]]++;",
            "",
            "    for (int i = 0; i < m; i++) cnt_t[t[i]]++;",
            "",
            "    for (int c = 97; c < 97 + 26; c++)",
            "        if (cnt_s[c] != cnt_t[c])",
            "            return false;",
            "",
            "    return true;",
            "}"
        ],
        "description": "Code snippet for isAnagram statement"
    },
    "arrRemoveDuplicates": {
        "prefix": "arrRemoveDuplicates",
        "body": [
            "int removeDuplicates(int *nums, int numsSize)",
            "{",
            "    int count = 0, i;",
            "    for (i = 1; i < numsSize; i++)",
            "    {",
            "        if (nums[i] == nums[i - 1])",
            "            count++;",
            "        else",
            "            nums[i - count] = nums[i];",
            "    }",
            "    return numsSize - count;",
            "}"
        ],
        "description": "Code snippet for arrRemoveDuplicates statement"
    },
    "arrRemoveDuplicatescn": {
        "prefix": "数组删除重复元素",
        "body": [
            "int removeDuplicates(int *nums, int numsSize)",
            "{",
            "    int count = 0, i;",
            "    for (i = 1; i < numsSize; i++)",
            "    {",
            "        if (nums[i] == nums[i - 1])",
            "            count++;",
            "        else",
            "            nums[i - count] = nums[i];",
            "    }",
            "    return numsSize - count;",
            "}"
        ],
        "description": "Code snippet for arrRemoveDuplicates statement"
    },
    "removeElement": {
        "prefix": "arrRemoveElement",
        "body": [
            "int removeElement(int *nums, int numsSize, int val)",
            "{",
            "    int i, start = 0;",
            "    for (i = 0; i < numsSize; i++)",
            "    {",
            "        if (nums[i] != val)",
            "            nums[start++] = nums[i];",
            "    }",
            "    return start;",
            "}"
        ],
        "description": "Code snippet for arrRemoveElement statement"
    },
    "removeElement": {
        "prefix": "数组删除元素",
        "body": [
            "int removeElement(int *nums, int numsSize, int val)",
            "{",
            "    int i, start = 0;",
            "    for (i = 0; i < numsSize; i++)",
            "    {",
            "        if (nums[i] != val)",
            "            nums[start++] = nums[i];",
            "    }",
            "    return start;",
            "}"
        ],
        "description": "Code snippet for arrRemoveElement statement"
    },
    "strFindSubStr": {
        "prefix": "strFindSubStr",
        "body": [
            "*",
            " * brute force approach",
            " * time complexity: O(mn)",
            " */",
            "int strStr(char *haystack, char *needle)",
            "{",
            "    int i = 0;",
            "    int j = 0;",
            "    int k = 0;",
            "    int hlen = 0;",
            "    int nlen = 0;",
            "",
            "    if (needle == NULL || *needle == 0)",
            "        return 0;",
            "",
            "    if (haystack == NULL || *haystack == 0)",
            "        return -1;",
            "",
            "    hlen = strlen(haystack);",
            "    nlen = strlen(needle);",
            "",
            "    if (hlen < nlen)",
            "        return -1;",
            "",
            "    for (i = 0; i <= hlen - nlen; i++)",
            "    {",
            "        j = 0;",
            "        if (haystack[i] != needle[j++])",
            "            continue;",
            "",
            "        k = i + 1;",
            "        for (; j < nlen; j++)",
            "        {",
            "            if (haystack[k] != needle[j])",
            "            {",
            "                break;",
            "            }",
            "            else",
            "                k++;",
            "        }",
            "        if (j == nlen)",
            "            return i;",
            "    }",
            "    return -1;",
            "}",
            "",
            "/* ----------------------------------------------------------------------------------------",
            " */",
            "",
            "/*",
            " * KMP algorithm",
            " * time complexity: O(m + n)",
            " */",
            "",
            "/* fills overlap with longest proper prefix which is also suffix for each index",
            " * in needle */",
            "void fill_overlap(char *needle, int len_needle, int *overlap)",
            "{",
            "    int len = 0;",
            "    int i = 0;",
            "",
            "    overlap[0] = 0;",
            "",
            "    for (i = 1; i < len_needle;)",
            "    {",
            "        if (needle[i] == needle[len])",
            "        {",
            "            len++;",
            "            overlap[i++] = len;",
            "        }",
            "        else",
            "        {",
            "            if (len)",
            "                len = overlap[len - 1];",
            "            else",
            "                overlap[i++] = 0;",
            "        }",
            "    }",
            "}",
            "",
            "int strStr(char *haystack, char *needle)",
            "{",
            "    int i = 0; /* index for haystack */",
            "    int j = 0; /* index for needle */",
            "",
            "    int len_needle = strlen(needle);",
            "    int len_haystack = strlen(haystack);",
            "",
            "    if (!len_needle)",
            "        return 0;",
            "",
            "    int overlap[len_needle];",
            "",
            "    fill_overlap(needle, len_needle, overlap);",
            "",
            "    while (i < len_haystack)",
            "    {",
            "        if (needle[j] == haystack[i])",
            "        {",
            "            i++;",
            "            j++;",
            "        }",
            "",
            "        if (j == len_needle)",
            "        {",
            "            return (i - j);",
            "        }",
            "        else if (i < len_haystack && needle[j] != haystack[i])",
            "        {",
            "            if (j != 0)",
            "                j = overlap[j - 1];",
            "            else",
            "                i = i + 1;",
            "        }",
            "    }",
            "    return -1;",
            "}"
        ],
        "description": "Code snippet for strFindSubStr statement"
    },
    "strFindSubStr": {
        "prefix": "字符串查找字串",
        "body": [
            "*",
            " * brute force approach",
            " * time complexity: O(mn)",
            " */",
            "int strStr(char *haystack, char *needle)",
            "{",
            "    int i = 0;",
            "    int j = 0;",
            "    int k = 0;",
            "    int hlen = 0;",
            "    int nlen = 0;",
            "",
            "    if (needle == NULL || *needle == 0)",
            "        return 0;",
            "",
            "    if (haystack == NULL || *haystack == 0)",
            "        return -1;",
            "",
            "    hlen = strlen(haystack);",
            "    nlen = strlen(needle);",
            "",
            "    if (hlen < nlen)",
            "        return -1;",
            "",
            "    for (i = 0; i <= hlen - nlen; i++)",
            "    {",
            "        j = 0;",
            "        if (haystack[i] != needle[j++])",
            "            continue;",
            "",
            "        k = i + 1;",
            "        for (; j < nlen; j++)",
            "        {",
            "            if (haystack[k] != needle[j])",
            "            {",
            "                break;",
            "            }",
            "            else",
            "                k++;",
            "        }",
            "        if (j == nlen)",
            "            return i;",
            "    }",
            "    return -1;",
            "}",
            "",
            "/* ----------------------------------------------------------------------------------------",
            " */",
            "",
            "/*",
            " * KMP algorithm",
            " * time complexity: O(m + n)",
            " */",
            "",
            "/* fills overlap with longest proper prefix which is also suffix for each index",
            " * in needle */",
            "void fill_overlap(char *needle, int len_needle, int *overlap)",
            "{",
            "    int len = 0;",
            "    int i = 0;",
            "",
            "    overlap[0] = 0;",
            "",
            "    for (i = 1; i < len_needle;)",
            "    {",
            "        if (needle[i] == needle[len])",
            "        {",
            "            len++;",
            "            overlap[i++] = len;",
            "        }",
            "        else",
            "        {",
            "            if (len)",
            "                len = overlap[len - 1];",
            "            else",
            "                overlap[i++] = 0;",
            "        }",
            "    }",
            "}",
            "",
            "int strStr(char *haystack, char *needle)",
            "{",
            "    int i = 0; /* index for haystack */",
            "    int j = 0; /* index for needle */",
            "",
            "    int len_needle = strlen(needle);",
            "    int len_haystack = strlen(haystack);",
            "",
            "    if (!len_needle)",
            "        return 0;",
            "",
            "    int overlap[len_needle];",
            "",
            "    fill_overlap(needle, len_needle, overlap);",
            "",
            "    while (i < len_haystack)",
            "    {",
            "        if (needle[j] == haystack[i])",
            "        {",
            "            i++;",
            "            j++;",
            "        }",
            "",
            "        if (j == len_needle)",
            "        {",
            "            return (i - j);",
            "        }",
            "        else if (i < len_haystack && needle[j] != haystack[i])",
            "        {",
            "            if (j != 0)",
            "                j = overlap[j - 1];",
            "            else",
            "                i = i + 1;",
            "        }",
            "    }",
            "    return -1;",
            "}"
        ],
        "description": "Code snippet for strFindSubStr statement"
    },
    "arrmoveZeroes": {
        "prefix": "arrmoveZeroes",
        "body": [
            "  void moveZeroes(int *nums, int numsSize)",
            "{",
            "    int i = 0, start = 0;",
            "",
            "    for (i = 0; i < numsSize; i++)",
            "    {",
            "        if (nums[i])",
            "            nums[start++] = nums[i];",
            "    }",
            "",
            "    for (start; start < numsSize; start++)",
            "    {",
            "        nums[start] = 0;",
            "    }",
            "}"
        ],
        "description": "Code snippet for arrmoveZeroes statement"
    },
    "arrmoveZeroes": {
        "prefix": "数组将零移至数组末尾",
        "body": [
            "  void moveZeroes(int *nums, int numsSize)",
            "{",
            "    int i = 0, start = 0;",
            "",
            "    for (i = 0; i < numsSize; i++)",
            "    {",
            "        if (nums[i])",
            "            nums[start++] = nums[i];",
            "    }",
            "",
            "    for (start; start < numsSize; start++)",
            "    {",
            "        nums[start] = 0;",
            "    }",
            "}"
        ],
        "description": "Code snippet for arrmoveZeroes statement"
    },
    "lengthOfLongestSubstring": {
        "prefix": "strlengthOfLongestSubstring",
        "body": [
            "int lengthOfLongestSubstring(char *str)",
            "{",
            "    int n = strlen(str);",
            "",
            "    if (!n)",
            "        return 0;",
            "",
            "    int L_len = 1;  // length of longest substring",
            "    int C_len = 1;  // length of current substring",
            "",
            "    int P_ind, i;      //  P_ind for previous index",
            "    int visited[256];  //  visited will keep track of visiting char for the last",
            "                       //  instance. since there are 256 ASCII char, its size is",
            "                       //  limited to that value.",
            "    memset(visited, -1, sizeof(int) * 256);",
            "    visited[str[0]] =",
            "        0;  //  the index of that char will tell us that when it was visited.",
            "    for (i = 1; i < n; i++)",
            "    {",
            "        P_ind = visited[str[i]];",
            "        if (P_ind == -1 || i - C_len > P_ind)",
            "            C_len++;  //  if the current char was not visited earlier, or it is",
            "                      //  not the part of current substring",
            "        else",
            "        {  //  otherwise, we need to change the current/longest substring length",
            "            if (C_len > L_len)",
            "                L_len = C_len;",
            "            C_len = i - P_ind;",
            "        }",
            "        visited[str[i]] = i;",
            "    }",
            "    if (C_len > L_len)",
            "        L_len = C_len;",
            "    return L_len;",
            "}"
        ],
        "description": "Code snippet for strlengthOfLongestSubstring statement"
    },
    "lengthOfLongestSubstring": {
        "prefix": "字符串最长无重复子串",
        "body": [
            "int lengthOfLongestSubstring(char *str)",
            "{",
            "    int n = strlen(str);",
            "",
            "    if (!n)",
            "        return 0;",
            "",
            "    int L_len = 1;  // length of longest substring",
            "    int C_len = 1;  // length of current substring",
            "",
            "    int P_ind, i;      //  P_ind for previous index",
            "    int visited[256];  //  visited will keep track of visiting char for the last",
            "                       //  instance. since there are 256 ASCII char, its size is",
            "                       //  limited to that value.",
            "    memset(visited, -1, sizeof(int) * 256);",
            "    visited[str[0]] =",
            "        0;  //  the index of that char will tell us that when it was visited.",
            "    for (i = 1; i < n; i++)",
            "    {",
            "        P_ind = visited[str[i]];",
            "        if (P_ind == -1 || i - C_len > P_ind)",
            "            C_len++;  //  if the current char was not visited earlier, or it is",
            "                      //  not the part of current substring",
            "        else",
            "        {  //  otherwise, we need to change the current/longest substring length",
            "            if (C_len > L_len)",
            "                L_len = C_len;",
            "            C_len = i - P_ind;",
            "        }",
            "        visited[str[i]] = i;",
            "    }",
            "    if (C_len > L_len)",
            "        L_len = C_len;",
            "    return L_len;",
            "}"
        ],
        "description": "Code snippet for strlengthOfLongestSubstring statement"
    },
    "strlongestValidParentheses": {
        "prefix": "strlongestValidParentheses",
        "body": [
            "#define max(x,y)(((x)>(y))?(x):(y))",
            "//The goal of this code is to find the length of the longest valid bracket substring in a given string s. It uses dynamic programming methods to solve this problem in a top-down approach.",
            "const int notCalculated = -2;",
            "const int notValid = -1;",
            "",
            "int getEndValidIndexFromDp(int* dp, char* s, int index, int lenS){",
            "    if (index >= lenS){",
            "        return notValid;",
            "    }",
            "",
            "    if (dp[index] == notCalculated){",
            "        dp[index] = getEndValidIndex(dp, s, index, lenS);",
            "    }",
            "",
            "    return dp[index];",
            "}",
            "",
            "int getEndValidIndex(int* dp, char* s, int index, int lenS){",
            "    if (s[index] == '('){",
            "        if (index + 1 >= lenS){",
            "            return notValid;",
            "        }",
            "",
            "        if (s[index + 1] == ')'){",
            "            return max(index + 1, getEndValidIndexFromDp(dp, s, index + 2, lenS));",
            "        }",
            "        ",
            "        int nextEndValidIndex = getEndValidIndexFromDp(dp, s, index + 1, lenS);",
            "        if (nextEndValidIndex == notValid || nextEndValidIndex + 1 >= lenS || s[nextEndValidIndex + 1] != ')') {",
            "            return notValid;",
            "        }",
            "        ",
            "        return max(nextEndValidIndex + 1, getEndValidIndexFromDp(dp, s, nextEndValidIndex + 2, lenS));",
            "    }",
            "    ",
            "    return notValid;",
            "}",
            "",
            "// Dynamic Programming. UP -> down approach.",
            "// Runtime: O(n)",
            "// Space: O(n)",
            "int longestValidParentheses(char * s){",
            "    int lenS = strlen(s);",
            "    if (lenS == 0){",
            "        return 0;",
            "    }",
            "",
            "    int* dp = malloc(lenS * sizeof(int));",
            "    for(int i = 0; i < lenS; i++){",
            "        dp[i] = notCalculated;",
            "    }",
            "",
            "    int result = 0;",
            "    for(int i = 0; i < lenS; i++){",
            "        result = max(result, getEndValidIndexFromDp(dp, s, i, lenS) - i + 1);",
            "    }",
            "    ",
            "    free(dp);",
            "    return result;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "strlongestValidParentheses": {
        "prefix": "字符串最长括号有效子串",
        "body": [
            "#define max(x,y)(((x)>(y))?(x):(y))",
            "//The goal of this code is to find the length of the longest valid bracket substring in a given string s. It uses dynamic programming methods to solve this problem in a top-down approach.",
            "const int notCalculated = -2;",
            "const int notValid = -1;",
            "",
            "int getEndValidIndexFromDp(int* dp, char* s, int index, int lenS){",
            "    if (index >= lenS){",
            "        return notValid;",
            "    }",
            "",
            "    if (dp[index] == notCalculated){",
            "        dp[index] = getEndValidIndex(dp, s, index, lenS);",
            "    }",
            "",
            "    return dp[index];",
            "}",
            "",
            "int getEndValidIndex(int* dp, char* s, int index, int lenS){",
            "    if (s[index] == '('){",
            "        if (index + 1 >= lenS){",
            "            return notValid;",
            "        }",
            "",
            "        if (s[index + 1] == ')'){",
            "            return max(index + 1, getEndValidIndexFromDp(dp, s, index + 2, lenS));",
            "        }",
            "        ",
            "        int nextEndValidIndex = getEndValidIndexFromDp(dp, s, index + 1, lenS);",
            "        if (nextEndValidIndex == notValid || nextEndValidIndex + 1 >= lenS || s[nextEndValidIndex + 1] != ')') {",
            "            return notValid;",
            "        }",
            "        ",
            "        return max(nextEndValidIndex + 1, getEndValidIndexFromDp(dp, s, nextEndValidIndex + 2, lenS));",
            "    }",
            "    ",
            "    return notValid;",
            "}",
            "",
            "// Dynamic Programming. UP -> down approach.",
            "// Runtime: O(n)",
            "// Space: O(n)",
            "int longestValidParentheses(char * s){",
            "    int lenS = strlen(s);",
            "    if (lenS == 0){",
            "        return 0;",
            "    }",
            "",
            "    int* dp = malloc(lenS * sizeof(int));",
            "    for(int i = 0; i < lenS; i++){",
            "        dp[i] = notCalculated;",
            "    }",
            "",
            "    int result = 0;",
            "    for(int i = 0; i < lenS; i++){",
            "        result = max(result, getEndValidIndexFromDp(dp, s, i, lenS) - i + 1);",
            "    }",
            "    ",
            "    free(dp);",
            "    return result;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "strreverseString": {
        "prefix": "strreverseString",
        "body": [
            "void reverseString(char *s, int sSize)",
            "{",
            "    int last = sSize - 1, i;",
            "    for (i = 0; i < last; i++)",
            "    {",
            "        char tmp = s[i];",
            "        s[i] = s[last];",
            "        s[last] = tmp;",
            "        last--;",
            "    }",
            "}"
        ],
        "description": "Code snippet for strreverseString statement"
    },
    "strreverseString": {
        "prefix": "字符串反转",
        "body": [
            "void reverseString(char *s, int sSize)",
            "{",
            "    int last = sSize - 1, i;",
            "    for (i = 0; i < last; i++)",
            "    {",
            "        char tmp = s[i];",
            "        s[i] = s[last];",
            "        s[last] = tmp;",
            "        last--;",
            "    }",
            "}"
        ],
        "description": "Code snippet for strreverseString statement"
    },
    "arrsearchInsert": {
        "prefix": "arrsearchInsert",
        "body": [
            "//Both functions are used to find the position where the target element target should be inserted in a sorted integer array nums to maintain the order of the array.",
            "int searchInsert(int *nums, int numsSize, int target)",
            "{",
            "    int low = 0, high = numsSize - 1, mid;",
            "    while (low <= high)",
            "    {",
            "        mid = low + (high - low) / 2;",
            "        if (target > nums[mid])",
            "            low = mid + 1;",
            "        else if (target < nums[mid])",
            "            high = mid - 1;",
            "        else",
            "            return mid;",
            "    }",
            "    return low;",
            "}",
            "",
            "/* Recursive version */",
            "int searchInsert(int *nums, int numsSize, int target)",
            "{",
            "    int idx = numsSize - 1;",
            "    if (numsSize > 0)",
            "    {",
            "        if (target > nums[idx])",
            "        {",
            "            return numsSize;",
            "        }",
            "        return searchInsert(nums, numsSize - 1, target);",
            "    }",
            "    return 0;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "arrsearchInsert": {
        "prefix": "字符串插入查找",
        "body": [
            "//Both functions are used to find the position where the target element target should be inserted in a sorted integer array nums to maintain the order of the array.",
            "int searchInsert(int *nums, int numsSize, int target)",
            "{",
            "    int low = 0, high = numsSize - 1, mid;",
            "    while (low <= high)",
            "    {",
            "        mid = low + (high - low) / 2;",
            "        if (target > nums[mid])",
            "            low = mid + 1;",
            "        else if (target < nums[mid])",
            "            high = mid - 1;",
            "        else",
            "            return mid;",
            "    }",
            "    return low;",
            "}",
            "",
            "/* Recursive version */",
            "int searchInsert(int *nums, int numsSize, int target)",
            "{",
            "    int idx = numsSize - 1;",
            "    if (numsSize > 0)",
            "    {",
            "        if (target > nums[idx])",
            "        {",
            "            return numsSize;",
            "        }",
            "        return searchInsert(nums, numsSize - 1, target);",
            "    }",
            "    return 0;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "isPerfectSquare": {
        "prefix": "isPerfectSquare",
        "body": [
            "bool isPerfectSquare(int num)",
            "{",
            "    for (long i = 1; i * i <= num; i++)",
            "        if (i * i == num)",
            "            return true;",
            "    return false;",
            "}",
            "//O(logn)",
            "bool isPerfectSquare(int num) {",
            "    long left = 1, right = num;",
            "    while (left <= right) {",
            "        long mid = left + (right - left) / 2;",
            "        long square = mid * mid;",
            "        if (square == num) {",
            "            return true;",
            "        } else if (square < num) {",
            "            left = mid + 1;",
            "        } else {",
            "            right = mid - 1;",
            "        }",
            "    }",
            "    return false;",
            "}"
        ],
        "description": "Code snippet for isPerfectSquare statement"
    },
    "isPerfectSquare": {
        "prefix": "数判断是否为完美平方",
        "body": [
            "bool isPerfectSquare(int num)",
            "{",
            "    for (long i = 1; i * i <= num; i++)",
            "        if (i * i == num)",
            "            return true;",
            "    return false;",
            "}",
            "//O(logn)",
            "bool isPerfectSquare(int num) {",
            "    long left = 1, right = num;",
            "    while (left <= right) {",
            "        long mid = left + (right - left) / 2;",
            "        long square = mid * mid;",
            "        if (square == num) {",
            "            return true;",
            "        } else if (square < num) {",
            "            left = mid + 1;",
            "        } else {",
            "            right = mid - 1;",
            "        }",
            "    }",
            "    return false;",
            "}"
        ],
        "description": "Code snippet for isPerfectSquare statement"
    },
    "algosolveSudoku": {
        "prefix": "algosolveSudoku",
        "body": [
            "int** initSet(int size){",
            "    int** result = (int**) malloc(size * sizeof(int*));",
            "    for (int i = 0; i < size; i++) {",
            "        result[i] = (int*)calloc(size, sizeof(int));",
            "    }",
            "    ",
            "    return result;    ",
            "}",
            "",
            "// Returns the id of triplet which the point (i, j) belongs to",
            "int getTripletId(int i, int j){",
            "    return (i / 3) * 3 + (j / 3);",
            "}",
            "",
            "// Recursive function which populates sudoku board.",
            "bool sudokuSolver(int startI, int startJ, char** board, int boardSize, int* boardColSize, int** horizontalsSets, int** verticalsSets, int** tripletsSets){",
            "    for (int i = startI; i < boardSize; i++) {",
            "        for (int j = startJ; j < boardColSize[i]; j++) {",
            "            if (board[i][j] != '.'){",
            "                continue;",
            "            }",
            "            ",
            "            // Find the sets of the current point (i, j)",
            "            int* horizontalSet = horizontalsSets[i];",
            "            int* verticalSet = verticalsSets[j];",
            "            int* tripletsSet = tripletsSets[getTripletId(i, j)];",
            "            ",
            "            for (int z = 1; z < 10; z++) {",
            "                if (horizontalSet[z] || verticalSet[z] || tripletsSet[z]){",
            "                    continue;",
            "                }",
            "                ",
            "                // If the z doesn't belong to occupations sets, we check this value to be in place",
            "                horizontalSet[z] = 1;",
            "                verticalSet[z] = 1;",
            "                tripletsSet[z] = 1;",
            "                ",
            "                if (sudokuSolver(i, j + 1, board, boardSize, boardColSize, horizontalsSets, verticalsSets, tripletsSets)){",
            "                    board[i][j] = z + '0';",
            "                    return true;",
            "                }",
            "                ",
            "                horizontalSet[z] = 0;",
            "                verticalSet[z] = 0;",
            "                tripletsSet[z] = 0;",
            "            }",
            "            ",
            "            // We tried all possible values in range 1-10. No variants - returns false;",
            "            return false;",
            "        }",
            "",
            "        // startJ to begin of the row.",
            "        startJ = 0;",
            "    }",
            "    ",
            "    // Reach it when the end of the board - then all previous values are setup correctly.",
            "    return true;",
            "}",
            "",
            "// Use backtracking",
            "void solveSudoku(char** board, int boardSize, int* boardColSize){",
            "    // Declare sets for cheking occupation of numbers by horizontals, verticals lines and triplets.",
            "    int** horizontalsSets = initSet(boardSize + 1);",
            "    int** verticalsSets = initSet(boardSize + 1);",
            "    int** tripletsSets = initSet(getTripletId(boardSize + 1, boardSize + 1));",
            "",
            "    // Populate sets with values from the board.",
            "    for (int i = 0; i < boardSize; i++) {",
            "        for (int j = 0; j < boardColSize[i]; j++) {",
            "            if (board[i][j] == '.'){",
            "                continue;",
            "            }",
            "            ",
            "            int value = board[i][j] - '0';",
            "            horizontalsSets[i][value] = 1;",
            "            verticalsSets[j][value] = 1;",
            "            tripletsSets[getTripletId(i, j)][value] = 1;",
            "        }",
            "    }",
            "",
            "    // Solving",
            "    sudokuSolver(0, 0, board, boardSize, boardColSize, horizontalsSets, verticalsSets, tripletsSets);",
            "",
            "    // Free resources",
            "    free(horizontalsSets);",
            "    free(verticalsSets);",
            "    free(tripletsSets);",
            "}"
        ],
        "description": "Code snippet for algosolveSudoku statement"
    },
    "algosolveSudoku": {
        "prefix": "算法数独问题",
        "body": [
            "int** initSet(int size){",
            "    int** result = (int**) malloc(size * sizeof(int*));",
            "    for (int i = 0; i < size; i++) {",
            "        result[i] = (int*)calloc(size, sizeof(int));",
            "    }",
            "    ",
            "    return result;    ",
            "}",
            "",
            "// Returns the id of triplet which the point (i, j) belongs to",
            "int getTripletId(int i, int j){",
            "    return (i / 3) * 3 + (j / 3);",
            "}",
            "",
            "// Recursive function which populates sudoku board.",
            "bool sudokuSolver(int startI, int startJ, char** board, int boardSize, int* boardColSize, int** horizontalsSets, int** verticalsSets, int** tripletsSets){",
            "    for (int i = startI; i < boardSize; i++) {",
            "        for (int j = startJ; j < boardColSize[i]; j++) {",
            "            if (board[i][j] != '.'){",
            "                continue;",
            "            }",
            "            ",
            "            // Find the sets of the current point (i, j)",
            "            int* horizontalSet = horizontalsSets[i];",
            "            int* verticalSet = verticalsSets[j];",
            "            int* tripletsSet = tripletsSets[getTripletId(i, j)];",
            "            ",
            "            for (int z = 1; z < 10; z++) {",
            "                if (horizontalSet[z] || verticalSet[z] || tripletsSet[z]){",
            "                    continue;",
            "                }",
            "                ",
            "                // If the z doesn't belong to occupations sets, we check this value to be in place",
            "                horizontalSet[z] = 1;",
            "                verticalSet[z] = 1;",
            "                tripletsSet[z] = 1;",
            "                ",
            "                if (sudokuSolver(i, j + 1, board, boardSize, boardColSize, horizontalsSets, verticalsSets, tripletsSets)){",
            "                    board[i][j] = z + '0';",
            "                    return true;",
            "                }",
            "                ",
            "                horizontalSet[z] = 0;",
            "                verticalSet[z] = 0;",
            "                tripletsSet[z] = 0;",
            "            }",
            "            ",
            "            // We tried all possible values in range 1-10. No variants - returns false;",
            "            return false;",
            "        }",
            "",
            "        // startJ to begin of the row.",
            "        startJ = 0;",
            "    }",
            "    ",
            "    // Reach it when the end of the board - then all previous values are setup correctly.",
            "    return true;",
            "}",
            "",
            "// Use backtracking",
            "void solveSudoku(char** board, int boardSize, int* boardColSize){",
            "    // Declare sets for cheking occupation of numbers by horizontals, verticals lines and triplets.",
            "    int** horizontalsSets = initSet(boardSize + 1);",
            "    int** verticalsSets = initSet(boardSize + 1);",
            "    int** tripletsSets = initSet(getTripletId(boardSize + 1, boardSize + 1));",
            "",
            "    // Populate sets with values from the board.",
            "    for (int i = 0; i < boardSize; i++) {",
            "        for (int j = 0; j < boardColSize[i]; j++) {",
            "            if (board[i][j] == '.'){",
            "                continue;",
            "            }",
            "            ",
            "            int value = board[i][j] - '0';",
            "            horizontalsSets[i][value] = 1;",
            "            verticalsSets[j][value] = 1;",
            "            tripletsSets[getTripletId(i, j)][value] = 1;",
            "        }",
            "    }",
            "",
            "    // Solving",
            "    sudokuSolver(0, 0, board, boardSize, boardColSize, horizontalsSets, verticalsSets, tripletsSets);",
            "",
            "    // Free resources",
            "    free(horizontalsSets);",
            "    free(verticalsSets);",
            "    free(tripletsSets);",
            "}"
        ],
        "description": "Code snippet for algosolveSudoku statement"
    },
    "strfirstUniqChar": {
        "prefix": "strfirstUniqChar",
        "body": [
            "int firstUniqChar(char *s)",
            "{",
            "    int *arr = calloc(256, sizeof(int));",
            "    int i;",
            "    for (i = 0; i < strlen(s); i++) arr[s[i]] = arr[s[i]] + 1;",
            "    for (i = 0; i < strlen(s); i++)",
            "    {",
            "        if (arr[s[i]] == 1)",
            "            return i;",
            "    }",
            "    return -1;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "strfirstUniqChar": {
        "prefix": "字符串第一个不重复的元素",
        "body": [
            "int firstUniqChar(char *s)",
            "{",
            "    int *arr = calloc(256, sizeof(int));",
            "    int i;",
            "    for (i = 0; i < strlen(s); i++) arr[s[i]] = arr[s[i]] + 1;",
            "    for (i = 0; i < strlen(s); i++)",
            "    {",
            "        if (arr[s[i]] == 1)",
            "            return i;",
            "    }",
            "    return -1;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "findTheDifference": {
        "prefix": "strfindTheDifference",
        "body": [
            "char findTheDifference(char *s, char *t)",
            "{",
            "    int sum1 = 0, sum2 = 0;",
            "    int i;",
            "    for (i = 0; i < strlen(s); i++) sum1 += s[i];",
            "    for (i = 0; i < strlen(t); i++) sum2 += t[i];",
            "    return (char)(sum2 - sum1);",
            "}"
        ],
        "description": "Code snippet for strfindTheDifference statement"
    },
    "findTheDifference": {
        "prefix": "字符串匹配",
        "body": [
            "char findTheDifference(char *s, char *t)",
            "{",
            "    int sum1 = 0, sum2 = 0;",
            "    int i;",
            "    for (i = 0; i < strlen(s); i++) sum1 += s[i];",
            "    for (i = 0; i < strlen(t); i++) sum2 += t[i];",
            "    return (char)(sum2 - sum1);",
            "}"
        ],
        "description": "Code snippet for strfindTheDifference statement"
    },
    "algotrap": {
        "prefix": "algotrap",
        "body": [
            "#define max(x,y)(((x)>(y))?(x):(y))",
            "#define min(x,y)(((x)<(y))?(x):(y))",
            "",
            "// Max stack. Runtime: O(n), Space: O(n)",
            "// Algorithm description: ",
            "// - Calculate the stack of maximums from right board.",
            "// - For each index find left maximum and right maximum of height",
            "// - The each index if heights could place nor greater than minimum of left and right max minus curr height",
            "// - Sum all index in result",
            "int trap(int* height, int heightSize){",
            "    int* rightMaxStack = malloc(heightSize * sizeof(int));",
            "    rightMaxStack[heightSize - 1] = height[heightSize - 1];",
            "",
            "    for (int i = heightSize - 2; i >= 0; i--){",
            "        rightMaxStack[i] = max(rightMaxStack[i + 1], height[i]);",
            "    }",
            "",
            "    int leftMax = 0;",
            "    int result = 0;",
            "    for (int i = 0; i < heightSize; i++){",
            "        leftMax = max(leftMax, height[i]);",
            "        result += max(0, min(leftMax, rightMaxStack[i]) - height[i]);",
            "    }",
            "    ",
            "    free(rightMaxStack);",
            "    return result;",
            "}"
        ],
        "description": "Code snippet for algotrap statement"
    },
    "algotrap": {
        "prefix": "算法接雨水问题",
        "body": [
            "#define max(x,y)(((x)>(y))?(x):(y))",
            "#define min(x,y)(((x)<(y))?(x):(y))",
            "",
            "// Max stack. Runtime: O(n), Space: O(n)",
            "// Algorithm description: ",
            "// - Calculate the stack of maximums from right board.",
            "// - For each index find left maximum and right maximum of height",
            "// - The each index if heights could place nor greater than minimum of left and right max minus curr height",
            "// - Sum all index in result",
            "int trap(int* height, int heightSize){",
            "    int* rightMaxStack = malloc(heightSize * sizeof(int));",
            "    rightMaxStack[heightSize - 1] = height[heightSize - 1];",
            "",
            "    for (int i = heightSize - 2; i >= 0; i--){",
            "        rightMaxStack[i] = max(rightMaxStack[i + 1], height[i]);",
            "    }",
            "",
            "    int leftMax = 0;",
            "    int result = 0;",
            "    for (int i = 0; i < heightSize; i++){",
            "        leftMax = max(leftMax, height[i]);",
            "        result += max(0, min(leftMax, rightMaxStack[i]) - height[i]);",
            "    }",
            "    ",
            "    free(rightMaxStack);",
            "    return result;",
            "}"
        ],
        "description": "Code snippet for algotrap statement"
    },
    "strcountSegments": {
        "prefix": "strcountSegments",
        "body": [
            "int countSegments(char * s){",
            "    int sLen = strlen(s);",
            "    int prevSpace = 1;",
            "    int result = 0;",
            "    char currChar;",
            "",
            "    for (int i = 0; i < sLen; i++){",
            "        currChar = s[i];",
            "",
            "        //A string of whitespaces will only be counted once as the condition below is only true when we transition from whitespace to non-whitespace.",
            "        //Since we start with assumed whitespace (prevSpace = 1), initial whitespaces are handled as well, if any",
            "        if (s[i] != ' ' && prevSpace) {",
            "            result++;",
            "        }",
            "        prevSpace = (currChar == ' ');",
            "    }",
            "",
            "    return result;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "strcountSegments": {
        "prefix": "字符串计算单词数",
        "body": [
            "int countSegments(char * s){",
            "    int sLen = strlen(s);",
            "    int prevSpace = 1;",
            "    int result = 0;",
            "    char currChar;",
            "",
            "    for (int i = 0; i < sLen; i++){",
            "        currChar = s[i];",
            "",
            "        //A string of whitespaces will only be counted once as the condition below is only true when we transition from whitespace to non-whitespace.",
            "        //Since we start with assumed whitespace (prevSpace = 1), initial whitespaces are handled as well, if any",
            "        if (s[i] != ' ' && prevSpace) {",
            "            result++;",
            "        }",
            "        prevSpace = (currChar == ' ');",
            "    }",
            "",
            "    return result;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "algoBFSjumpGame": {
        "prefix": "algoBFSjumpGame",
        "body": [
            "// Breadth-first search, imitation.",
            "// Runtime: O(n)",
            "// Space: O(n)",
            "int jump(int* nums, int numsSize) {",
            "    if (numsSize == 1) {",
            "        return 0;",
            "    }",
            "",
            "    int step = 1;",
            "    int* visitedCells = calloc(numsSize, sizeof(int));",
            "",
            "    int* queue = malloc(numsSize * sizeof(int));",
            "    queue[0] = 0;",
            "    int queueLength = 1;",
            "",
            "    while (queueLength > 0){",
            "        int* nextQueue = malloc(numsSize * sizeof(int));",
            "        int nextQueueLength = 0;",
            "",
            "        for (int i = 0; i < queueLength; i++) {",
            "            int cell = queue[i];",
            "            int jump = nums[cell];",
            "",
            "            if (cell + jump >= numsSize - 1) {",
            "                free(visitedCells);",
            "                free(queue);",
            "                free(nextQueue);",
            "                return step;",
            "            }",
            "",
            "            // populate next queue wave for searching",
            "            for (int nextCell = cell; nextCell <= cell + jump; nextCell++) {",
            "                if (visitedCells[nextCell] == 0){",
            "                    nextQueue[nextQueueLength++] = nextCell;",
            "                    visitedCells[nextCell] = 1;",
            "                }",
            "            }",
            "        }",
            "",
            "        step++;",
            "        free(queue);",
            "",
            "        queue = nextQueue;",
            "        queueLength = nextQueueLength;",
            "    }",
            "",
            "    free(visitedCells);",
            "    free(queue);",
            "    return -1;",
            "}"
        ],
        "description": "Code snippet for algoBFSjumpGame statement"
    },
    "algoBFSjumpGame": {
        "prefix": "算法BFS跳跃问题",
        "body": [
            "// Breadth-first search, imitation.",
            "// Runtime: O(n)",
            "// Space: O(n)",
            "int jump(int* nums, int numsSize) {",
            "    if (numsSize == 1) {",
            "        return 0;",
            "    }",
            "",
            "    int step = 1;",
            "    int* visitedCells = calloc(numsSize, sizeof(int));",
            "",
            "    int* queue = malloc(numsSize * sizeof(int));",
            "    queue[0] = 0;",
            "    int queueLength = 1;",
            "",
            "    while (queueLength > 0){",
            "        int* nextQueue = malloc(numsSize * sizeof(int));",
            "        int nextQueueLength = 0;",
            "",
            "        for (int i = 0; i < queueLength; i++) {",
            "            int cell = queue[i];",
            "            int jump = nums[cell];",
            "",
            "            if (cell + jump >= numsSize - 1) {",
            "                free(visitedCells);",
            "                free(queue);",
            "                free(nextQueue);",
            "                return step;",
            "            }",
            "",
            "            // populate next queue wave for searching",
            "            for (int nextCell = cell; nextCell <= cell + jump; nextCell++) {",
            "                if (visitedCells[nextCell] == 0){",
            "                    nextQueue[nextQueueLength++] = nextCell;",
            "                    visitedCells[nextCell] = 1;",
            "                }",
            "            }",
            "        }",
            "",
            "        step++;",
            "        free(queue);",
            "",
            "        queue = nextQueue;",
            "        queueLength = nextQueueLength;",
            "    }",
            "",
            "    free(visitedCells);",
            "    free(queue);",
            "    return -1;",
            "}"
        ],
        "description": "Code snippet for algoBFSjumpGame statement"
    },
    "bithammingDistance": {
        "prefix": "bithammingDistance",
        "body": [
            "int hammingDistance(int x, int y)",
            "{",
            "    int difference =",
            "        x ^ y;  // The XOR operator generates the bitwise difference in the",
            "                // binary representation of two numbers If bit in ith position",
            "                // of both numbers is same, bit in difference is 0, otherwise 1",
            "    int TotalBits = sizeof(difference) * 8;  // total number of bits",
            "    int i, distance = 0;",
            "    for (i = 0; i < TotalBits; i++)",
            "    {",
            "        if (difference &",
            "            (UINT32_C(1)",
            "             << i))  // if the bit on the ith position of 32 bit input is 1,",
            "                     // then proceed Further note the use of UINT32_C to convert",
            "                     // 1 to unsigned 32 bit int, as just 1 is treated as int",
            "                     // which cannot be shifted left more than 30 times",
            "            distance += 1;",
            "    }",
            "    return distance;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "bithammingDistance": {
        "prefix": "二进制表示中有多少位不同",
        "body": [
            "// O(1)",
            "int hammingDistance(int x, int y)",
            "{",
            "    int difference =",
            "        x ^ y;  // The XOR operator generates the bitwise difference in the",
            "                // binary representation of two numbers If bit in ith position",
            "                // of both numbers is same, bit in difference is 0, otherwise 1",
            "    int TotalBits = sizeof(difference) * 8;  // total number of bits",
            "    int i, distance = 0;",
            "    for (i = 0; i < TotalBits; i++)",
            "    {",
            "        if (difference &",
            "            (UINT32_C(1)",
            "             << i))  // if the bit on the ith position of 32 bit input is 1,",
            "                     // then proceed Further note the use of UINT32_C to convert",
            "                     // 1 to unsigned 32 bit int, as just 1 is treated as int",
            "                     // which cannot be shifted left more than 30 times",
            "            distance += 1;",
            "    }",
            "    return distance;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "bitfindComplement": {
        "prefix": "bitfindComplement",
        "body": [
            "int findComplement(int num)",
            "{",
            "    int TotalBits = 0;",
            "    int temp = num;",
            "    while (temp)",
            "    {  // To find position of MSB in given num. Since num is represented as a",
            "       // standard size in memory, we cannot rely on size for that information.",
            "        TotalBits++;  // increment TotalBits till temp becomes 0",
            "        temp >>= 1;   // shift temp right by 1 bit every iteration; temp loses 1",
            "                      // bit to underflow every iteration till it becomes 0",
            "    }",
            "    int i,",
            "        flipNumber = 1;  // Eg: 1's complement of 101(binary) can be found as",
            "                         // 101^111 (XOR with 111 flips all bits that are 1 to 0",
            "                         // and flips 0 to 1)",
            "    for (i = 1; i < TotalBits; i++)",
            "    {",
            "        flipNumber += UINT32_C(1)",
            "                      << i;  // Note the use of unsigned int to facilitate left",
            "                             // shift more than 31 times, if needed",
            "    }",
            "    num = num ^ flipNumber;",
            "    return num;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "bitfindComplement": {
        "prefix": "补数",
        "body": [
            "int findComplement(int num)",
            "{",
            "    int TotalBits = 0;",
            "    int temp = num;",
            "    while (temp)",
            "    {  // To find position of MSB in given num. Since num is represented as a",
            "       // standard size in memory, we cannot rely on size for that information.",
            "        TotalBits++;  // increment TotalBits till temp becomes 0",
            "        temp >>= 1;   // shift temp right by 1 bit every iteration; temp loses 1",
            "                      // bit to underflow every iteration till it becomes 0",
            "    }",
            "    int i,",
            "        flipNumber = 1;  // Eg: 1's complement of 101(binary) can be found as",
            "                         // 101^111 (XOR with 111 flips all bits that are 1 to 0",
            "                         // and flips 0 to 1)",
            "    for (i = 1; i < TotalBits; i++)",
            "    {",
            "        flipNumber += UINT32_C(1)",
            "                      << i;  // Note the use of unsigned int to facilitate left",
            "                             // shift more than 31 times, if needed",
            "    }",
            "    num = num ^ flipNumber;",
            "    return num;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "floatPow": {
        "prefix": "floatPow",
        "body": [
            "double powPositive(double x, int n){",
            "    if (n == 1){",
            "        return x;",
            "    }",
            "",
            "    double val = powPositive(x, n / 2);",
            "    double result = val * val;",
            "    ",
            "    // if n is odd",
            "    if (n & 1 > 0){",
            "        result *= x;",
            "    }",
            "",
            "    return result;",
            "}",
            "",
            "// Divide and conquer.",
            "// Runtime: O(log(n))",
            "// Space: O(1)",
            "double myPow(double x, int n){",
            "    if (n == 0){",
            "        return 1;",
            "    }",
            "",
            "    const int LOWER_BOUND = -2147483648;",
            "",
            "    // n is the minimum int, couldn't be converted in -n because maximum is 2147483647.",
            "    // this case we use (1 / pow(x, -(n + 1))) * n",
            "    if (n == LOWER_BOUND){",
            "        return 1 / (powPositive(x, -(n + 1)) * x);",
            "    }",
            "",
            "    // 1 / pow(x, -(n + 1))",
            "    if (n < 0){",
            "        return 1 / powPositive(x, -n);",
            "    }",
            "",
            "    return powPositive(x, n);",
            "}"
        ],
        "description": "Code snippet for floatPow statement"
    },
    "floatPow": {
        "prefix": "算法浮点数幂计算",
        "body": [
            "double powPositive(double x, int n){",
            "    if (n == 1){",
            "        return x;",
            "    }",
            "",
            "    double val = powPositive(x, n / 2);",
            "    double result = val * val;",
            "    ",
            "    // if n is odd",
            "    if (n & 1 > 0){",
            "        result *= x;",
            "    }",
            "",
            "    return result;",
            "}",
            "",
            "// Divide and conquer.",
            "// Runtime: O(log(n))",
            "// Space: O(1)",
            "double myPow(double x, int n){",
            "    if (n == 0){",
            "        return 1;",
            "    }",
            "",
            "    const int LOWER_BOUND = -2147483648;",
            "",
            "    // n is the minimum int, couldn't be converted in -n because maximum is 2147483647.",
            "    // this case we use (1 / pow(x, -(n + 1))) * n",
            "    if (n == LOWER_BOUND){",
            "        return 1 / (powPositive(x, -(n + 1)) * x);",
            "    }",
            "",
            "    // 1 / pow(x, -(n + 1))",
            "    if (n < 0){",
            "        return 1 / powPositive(x, -n);",
            "    }",
            "",
            "    return powPositive(x, n);",
            "}"
        ],
        "description": "Code snippet for floatPow statement"
    },
    "strdetectCapitalUse": {
        "prefix": "strdetectCapitalUse",
        "body": [
            "bool detectCapitalUse(char *word)",
            "{",
            "    int len = strlen(word);",
            "    if (len == 1)",
            "        return 1;",
            "    int countUpper = 0, i;",
            "    for (i = 0; i < len; i++)",
            "    {",
            "        if (isupper(word[i]))",
            "            countUpper++;",
            "    }",
            "    /* All lower case */",
            "    if (countUpper == 0)",
            "        return 1;",
            "    /* 1st character is upper, and the rest is lower case */",
            "    if (countUpper == 1 && isupper(word[0]))",
            "        return 1;",
            "    /* Check all character is upper case? */",
            "    else",
            "        return countUpper == len;",
            "}",
            "",
            "/* Another way */",
            "bool isAllUpper(char *word)",
            "{",
            "    int len = strlen(word);",
            "    for (int i = 0; i < len; i++)",
            "    {",
            "        if (islower(word[i]))",
            "            return 0;",
            "    }",
            "    return 1;",
            "}",
            "bool detectCapitalUse(char *word)",
            "{",
            "    int len = strlen(word);",
            "    for (int i = 1; i < len; i++)",
            "    {",
            "        if (isupper(word[i]) && !isAllUpper(word))",
            "            return 0;",
            "    }",
            "    return 1;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "strdetectCapitalUse": {
        "prefix": "字符串检查大小写",
        "body": [
            "bool detectCapitalUse(char *word)",
            "{",
            "    int len = strlen(word);",
            "    if (len == 1)",
            "        return 1;",
            "    int countUpper = 0, i;",
            "    for (i = 0; i < len; i++)",
            "    {",
            "        if (isupper(word[i]))",
            "            countUpper++;",
            "    }",
            "    /* All lower case */",
            "    if (countUpper == 0)",
            "        return 1;",
            "    /* 1st character is upper, and the rest is lower case */",
            "    if (countUpper == 1 && isupper(word[0]))",
            "        return 1;",
            "    /* Check all character is upper case? */",
            "    else",
            "        return countUpper == len;",
            "}",
            "",
            "/* Another way */",
            "bool isAllUpper(char *word)",
            "{",
            "    int len = strlen(word);",
            "    for (int i = 0; i < len; i++)",
            "    {",
            "        if (islower(word[i]))",
            "            return 0;",
            "    }",
            "    return 1;",
            "}",
            "bool detectCapitalUse(char *word)",
            "{",
            "    int len = strlen(word);",
            "    for (int i = 1; i < len; i++)",
            "    {",
            "        if (isupper(word[i]) && !isAllUpper(word))",
            "            return 0;",
            "    }",
            "    return 1;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "arrayPairSum": {
        "prefix": "arrayPairSum",
        "body": [
            "int cmpval(const void *a, const void *b) { return *(int *)a - *(int *)b; }",
            "int arrayPairSum(int *nums, int numsSize)",
            "{",
            "    int sum = 0, i;",
            "    qsort(nums, numsSize, sizeof(int), cmpval);",
            "    for (i = 0; i < numsSize; i = i + 2) sum = sum + nums[i];",
            "    return sum;",
            "}"
        ],
        "description": "Code snippet for arrayPairSum statement"
    },
    "arrayPairSum": {
        "prefix": "数组分割查找两两配对元素最小值",
        "body": [
            "int cmpval(const void *a, const void *b) { return *(int *)a - *(int *)b; }",
            "int arrayPairSum(int *nums, int numsSize)",
            "{",
            "    int sum = 0, i;",
            "    qsort(nums, numsSize, sizeof(int), cmpval);",
            "    for (i = 0; i < numsSize; i = i + 2) sum = sum + nums[i];",
            "    return sum;",
            "}"
        ],
        "description": "Code snippet for arrayPairSum statement"
    },
    "treetrimBST": {
        "prefix": "algotrimBST",
        "body": [
            "/**",
            " * Definition for a binary tree node.",
            " * struct TreeNode {",
            " *     int val;",
            " *     struct TreeNode *left;",
            " *     struct TreeNode *right;",
            " * This code implements a binary search tree pruning function trimBST, which is used to trim a given binary search tree so that the values of all its nodes are within the specified range [low, high].",
            " * };",
            " */",
            "",
            "",
            "// Depth-First Search",
            "// Runtime: O(n)",
            "// Space: O(1)",
            "struct TreeNode* trimBST(struct TreeNode* root, int low, int high){",
            "    if (root == NULL){",
            "        return NULL;",
            "    }",
            "    ",
            "    if (root->val > high){",
            "        return trimBST(root->left, low, high);",
            "    }",
            "",
            "    if (root->val < low){",
            "        return trimBST(root->right, low, high);",
            "    }",
            "    ",
            "    root->left = trimBST(root->left, low, high);",
            "    root->right = trimBST(root->right, low, high);",
            "    return root;",
            "}"
        ],
        "description": "Code snippet for treetrimBST statement"
    },
    "treetrimBST": {
        "prefix": "算法二叉搜索树修剪函数",
        "body": [
            "/**",
            " * Definition for a binary tree node.",
            " * struct TreeNode {",
            " *     int val;",
            " *     struct TreeNode *left;",
            " *     struct TreeNode *right;",
            " * This code implements a binary search tree pruning function trimBST, which is used to trim a given binary search tree so that the values of all its nodes are within the specified range [low, high].",
            " * };",
            " */",
            "",
            "",
            "// Depth-First Search",
            "// Runtime: O(n)",
            "// Space: O(1)",
            "struct TreeNode* trimBST(struct TreeNode* root, int low, int high){",
            "    if (root == NULL){",
            "        return NULL;",
            "    }",
            "    ",
            "    if (root->val > high){",
            "        return trimBST(root->left, low, high);",
            "    }",
            "",
            "    if (root->val < low){",
            "        return trimBST(root->right, low, high);",
            "    }",
            "    ",
            "    root->left = trimBST(root->left, low, high);",
            "    root->right = trimBST(root->right, low, high);",
            "    return root;",
            "}"
        ],
        "description": "Code snippet for treetrimBST statement"
    },
    "compareTimeStrings": {
        "prefix": "compareTimeStrings",
        "body": [
            "#include <time.h>",
            "int compareTimeStrings(const char *timeStr1, const char *timeStr2) {",
            "    struct tm tm1, tm2;",
            "    time_t time1, time2;",
            "",
            "    // 使用strptime解析时间字符串",
            "    if (strptime(timeStr1, \"%Y-%m-%d %H:%M:%S\", &tm1) == NULL) {",
            "        return -1;",
            "    }",
            "",
            "    if (strptime(timeStr2, %Y-%m-%d %H:%M:%S, &tm2) == NULL) {",
            "        return -1;",
            "    }",
            "",
            "    // 将tm结构转换为time_t（秒数）",
            "    time1 = mktime(&tm1);",
            "    time2 = mktime(&tm2);",
            "",
            "    if (time1 == -1 || time2 == -1) {",
            "        return -1;",
            "    }",
            "",
            "    // 比较时间",
            "    if (time1 < time2) {",
            "        return -1;",
            "    } else if (time1 > time2) {",
            "        return 1;",
            "    } else {",
            "        return 0;",
            "    }",
            "}"
        ],
        "description": "Code snippet for compareTimeStrings statement"
    },
    "compareTimeStrings": {
        "prefix": "比较两个时间字符串",
        "body": [
            "#include <time.h>",
            "int compareTimeStrings(const char *timeStr1, const char *timeStr2) {",
            "    struct tm tm1, tm2;",
            "    time_t time1, time2;",
            "",
            "    // 使用strptime解析时间字符串",
            "    if (strptime(timeStr1, \"%Y-%m-%d %H:%M:%S\", &tm1) == NULL) {",
            "        return -1;",
            "    }",
            "",
            "    if (strptime(timeStr2, %Y-%m-%d %H:%M:%S, &tm2) == NULL) {",
            "        return -1;",
            "    }",
            "",
            "    // 将tm结构转换为time_t（秒数）",
            "    time1 = mktime(&tm1);",
            "    time2 = mktime(&tm2);",
            "",
            "    if (time1 == -1 || time2 == -1) {",
            "        return -1;",
            "    }",
            "",
            "    // 比较时间",
            "    if (time1 < time2) {",
            "        return -1;",
            "    } else if (time1 > time2) {",
            "        return 1;",
            "    } else {",
            "        return 0;",
            "    }",
            "}"
        ],
        "description": "Code snippet for compareTimeStrings statement"
    },
    "compareTimeWithCurrentTime": {
        "prefix": "compareTimeWithCurrentTime",
        "body": [
            "#include <time.h>",
            "int compareTimeWithCurrentTime(const char *timeStr1) {",
            "    struct tm tm1, tm2;",
            "    time_t currentTime;",
            "    ",
            "    // 获取当前时间",
            "    time(&currentTime);",
            "    ",
            "    // 将当前时间转换为 tm 结构",
            "    localtime_r(&currentTime, &tm2);",
            "    ",
            "    // 将 timeStr1 转换为 tm 结构",
            "    if (strptime(timeStr1, \"%Y-%m-%d %H:%M:%S\", &tm1) == NULL) {",
            "        return -1;  // 返回错误代码",
            "    }",
            "",
            "    // 将 tm 结构转换为 time_t 类型",
            "    time_t time1 = mktime(&tm1);",
            "    time_t time2 = mktime(&tm2);",
            "",
            "    if (time1 < time2) {",
            "        return -1;  // timeStr1 早于当前时间",
            "    } else if (time1 > time2) {",
            "        return 1;   // timeStr1 晚于当前时间",
            "    } else {",
            "        return 0;   // timeStr1 与当前时间相等",
            "    }",
            "}"
        ],
        "description": "Code snippet for compareTimeWithCurrentTime statement"
    },
    "compareTimeWithCurrentTime": {
        "prefix": "时间字符串和当前时间作比较",
        "body": [
            "#include <time.h>",
            "int compareTimeWithCurrentTime(const char *timeStr1) {",
            "    struct tm tm1, tm2;",
            "    time_t currentTime;",
            "    ",
            "    // 获取当前时间",
            "    time(&currentTime);",
            "    ",
            "    // 将当前时间转换为 tm 结构",
            "    localtime_r(&currentTime, &tm2);",
            "    ",
            "    // 将 timeStr1 转换为 tm 结构",
            "    if (strptime(timeStr1, \"%Y-%m-%d %H:%M:%S\", &tm1) == NULL) {",
            "        return -1;  // 返回错误代码",
            "    }",
            "",
            "    // 将 tm 结构转换为 time_t 类型",
            "    time_t time1 = mktime(&tm1);",
            "    time_t time2 = mktime(&tm2);",
            "",
            "    if (time1 < time2) {",
            "        return -1;  // timeStr1 早于当前时间",
            "    } else if (time1 > time2) {",
            "        return 1;   // timeStr1 晚于当前时间",
            "    } else {",
            "        return 0;   // timeStr1 与当前时间相等",
            "    }",
            "}"
        ],
        "description": "Code snippet for compareTimeWithCurrentTime statement"
    },
    "findStringInArray": {
        "prefix": "strfindStringInArray",
        "body": [
            "char *stringArray[3] = {\"abc\",\"abc\"\"abc\"};",
            "char *target = {\"abc\"};",
            "int findStringInArray(const char *target, const char *stringArray[], int arraySize) {",
            "    for (int i = 0; i < arraySize; i++) {",
            "        if (strcmp(target, stringArray[i]) == 0) {",
            "            return i;  // 返回匹配到的位置",
            "        }",
            "    }",
            "    return -1;  // 未找到匹配项",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "findStringInArray": {
        "prefix": "字符串数组中匹配字符串",
        "body": [
            "char *stringArray[3] = {\"abc\",\"abc\"\"abc\"};",
            "char *target = {\"abc\"};",
            "int findStringInArray(const char *target, const char *stringArray[], int arraySize) {",
            "    for (int i = 0; i < arraySize; i++) {",
            "        if (strcmp(target, stringArray[i]) == 0) {",
            "            return i;  // 返回匹配到的位置",
            "        }",
            "    }",
            "    return -1;  // 未找到匹配项",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "removeSpaces": {
        "prefix": "strremoveSpaces",
        "body": [
            "void removeSpaces(char *str) {",
            "    int len = strlen(str);",
            "    int i, j = 0;",
            "",
            "    for (i = 0; i < len; i++) {",
            "        if (str[i] != ' ') {",
            "            str[j] = str[i];",
            "            j++;",
            "        }",
            "    }",
            "    str[j] = '\\0'; // 在新字符串的末尾添加 null 终止符，以确保字符串正确终止",
            "}"
        ],
        "description": "Code snippet for strremoveSpaces statement"
    },
    "removeSpaces": {
        "prefix": "字符串移除空格",
        "body": [
            "void removeSpaces(char *str) {",
            "    int len = strlen(str);",
            "    int i, j = 0;",
            "",
            "    for (i = 0; i < len; i++) {",
            "        if (str[i] != ' ') {",
            "            str[j] = str[i];",
            "            j++;",
            "        }",
            "    }",
            "    str[j] = '\\0'; // 在新字符串的末尾添加 null 终止符，以确保字符串正确终止",
            "}"
        ],
        "description": "Code snippet for strremoveSpaces statement"
    },
    "strlen": {
        "prefix": "strlen",
        "body": [
            "strlen(&str) == 0;"
        ],
        "description": "Code snippet for switch statement"
    },
    "strlen": {
        "prefix": "字符串长度",
        "body": [
            "strlen(&str) == 0;"
        ],
        "description": "Code snippet for switch statement"
    },
    "strcmp": {
        "prefix": "strcmp",
        "body": [
            "strcmp(&str1, &str2) == 0;"
        ],
        "description": "Code snippet for switch statement"
    },
    "strcmp": {
        "prefix": "字符串比较",
        "body": [
            "strcmp(&str1, &str2) == 0;"
        ],
        "description": "Code snippet for switch statement"
    },
    "sprintf": {
        "prefix": "sprintf",
        "body": [
            "sprintf(&str, \"%s\", &str2);"
        ],
        "description": "Code snippet for switch statement"
    },
    "switch": {
        "prefix": "switch",
        "body": [
            "swi"
        ],
        "description": "Code snippet for switch statement"
    },
}