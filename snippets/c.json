{
    "for": {
        "prefix": "for",
        "body": [
            "for (${size_t} ${i} = ${1:0}; ${i} < ${2:length}; ${i}++)",
            "{",
			"	$3",
            "}"
        ],
        "description": "Code snippet for 'for' loop"
    },
    "forr": {
        "prefix": "forr",
        "body": [
            "for (int ${i} = ${1:length} - 1; ${i} >= ${2:0}; ${i}--)",
            "{",
			"	$3",
            "}"
        ],
        "description": "Code snippet for reverse 'for' loop"
    },
    "while": {
        "prefix": "while",
        "body": [
            "while ($1)",
            "{",
			"	$2",
            "}"
        ],
        "description": ""
    },
    "if": {
        "prefix": "if",
        "body": [
            "if ($1)",
            "{",
			"	$2",
            "}"
        ],
        "description": "Code snippet for if statement"
    },
    "else": {
        "prefix": "else",
        "body": [
            "else",
            "{",
			"	$1",
            "}"
        ],
        "description": "Code snippet for else statement"
    },
    "else if": {
        "prefix": "else if",
        "body": [
            "else if ($1)",
            "{",
			"	$2",
            "}"
        ],
        "description": "Code snippet for else-if statement"
    },
    "enum": {
        "prefix": "enum",
        "body": [
            "enum ${MyEnum}",
            "{",
			"	$1",
            "};"
        ],
        "description": "Code snippet for enum"
    },
    "#ifdef": {
        "prefix": "#ifdef",
        "body": [
            "#ifdef ${DEBUG}",
            "$1",
            "#endif // ${DEBUG}"
        ],
        "description": "Code snippet for #ifdef"
    },
    "#ifndef": {
        "prefix": "#ifndef",
        "body": [
            "#ifndef ${1:1}",
            "$2",
            "#endif // !$1"
        ],
        "description": "Code snippet for #ifndef"
    },
    "#if": {
        "prefix": "#if",
        "body": [
            "#ifdef ${1:0}",
            "$2",
            "#endif // $1"
        ],
        "description": "Code snippet for #if"
    },
    "struct": {
        "prefix": "struct",
        "body": [
            "struct ${MyStruct}",
            "{",
			"	$1",
            "};"
        ],
        "description": "Code snippet for struct"
    },
    "switch": {
        "prefix": "switch",
        "body": [
            "switch (${switch_on})",
            "{",
            "default:",
			"	break;$1",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "union": {
        "prefix": "union",
        "body": [
            "union ${MyUnion}",
            "{",
			"	$1",
            "};"
        ],
        "description": "Code snippet for union"
    },
    "#inc": {
        "prefix": "#inc",
        "body": [
            "#include \"$1\""
        ],
        "description": "Code snippet for #include \" \""
    },
    "#inc<": {
        "prefix": "#inc<",
        "body": [
            "#include <$1>"
        ],
        "description": "Code snippet for #include \" \""
    },
    "#def": {
        "prefix": "#def",
        "body": [
            "#define \"$1\" \"$2\" "
        ],
        "description": "Code snippet for #define \" \""
    },
    "#def": {
        "prefix": "#def",
        "body": [
            "#define \"$1\" \"$2\" "
        ],
        "description": "Code snippet for #define \" \""
    },
    "bubblesort": {
        "prefix": "arrBubblesort",
        "body": [
            "// 冒泡排序函数",
            "void bubbleSort(int arr[], int n) {",
            "    int temp;",
            "    int swapped;",
            "",
            "    for (int i = 0; i < n - 1; i++) {",
            "        swapped = 0; // 用于标记是否发生了交换",
            "",
            "        for (int j = 0; j < n - i - 1; j++) {",
            "            if (arr[j] > arr[j + 1]) {",
            "                // 交换arr[j]和arr[j+1]的位置",
            "                temp = arr[j];",
            "                arr[j] = arr[j + 1];",
            "                arr[j + 1] = temp;",
            "                swapped = 1; // 标记已发生交换",
            "            }",
            "        }",
            "",
            "        // 如果在本轮没有发生交换，说明数组已经有序，可以提前退出",
            "        if (swapped == 0) {",
            "            break;",
            "        }",
            "    }",
            "}"
        ],
        "description": "Code snippet forbubblesort \" \""
    },
    "bubblesort_cn": {
        "prefix": "数组冒泡排序",
        "body": [
            "// 冒泡排序函数",
            "void bubbleSort(int arr[], int n) {",
            "    int temp;",
            "    int swapped;",
            "",
            "    for (int i = 0; i < n - 1; i++) {",
            "        swapped = 0; // 用于标记是否发生了交换",
            "",
            "        for (int j = 0; j < n - i - 1; j++) {",
            "            if (arr[j] > arr[j + 1]) {",
            "                // 交换arr[j]和arr[j+1]的位置",
            "                temp = arr[j];",
            "                arr[j] = arr[j + 1];",
            "                arr[j + 1] = temp;",
            "                swapped = 1; // 标记已发生交换",
            "            }",
            "        }",
            "",
            "        // 如果在本轮没有发生交换，说明数组已经有序，可以提前退出",
            "        if (swapped == 0) {",
            "            break;",
            "        }",
            "    }",
            "}"
        ],
        "description": "Code snippet forbubblesort \" \""
    },
    "find_min_arr": {
        "prefix": "arrFindminarr",
        "body": [
            "int findMin(int arr[], int n) {",
            "    if (n <= 0) {",
            "        // 处理无效输入",
            "        printf(error);",
            "        return -1; // 返回一个标志值表示错误",
            "    }",
            "",
            "    int min = arr[0]; // 假定第一个元素为最小值",
            "",
            "    // 遍历数组，比较找到最小值",
            "    for (int i = 1; i < n; i++) {",
            "        if (arr[i] < min) {",
            "            min = arr[i]; // 更新最小值",
            "        }",
            "    }",
            "",
            "    return min;",
            "}"
        ],
        "description": "Code snippet for findminarr"
    },
    "find_min_arr_cn": {
        "prefix": "数组查找数组最小值",
        "body": [
            "int findMin(int arr[], int n) {",
            "    if (n <= 0) {",
            "        // 处理无效输入",
            "        printf(error);",
            "        return -1; // 返回一个标志值表示错误",
            "    }",
            "",
            "    int min = arr[0]; // 假定第一个元素为最小值",
            "",
            "    // 遍历数组，比较找到最小值",
            "    for (int i = 1; i < n; i++) {",
            "        if (arr[i] < min) {",
            "            min = arr[i]; // 更新最小值",
            "        }",
            "    }",
            "",
            "    return min;",
            "}"
        ],
        "description": "Code snippet for 查找数组最小值"
    },
    "selectionSort": {
        "prefix": "arrSelectionSort",
        "body": [
            "// 选择排序函数",
            "void selectionSort(int arr[], int n) {",
            "    int i, j, minIndex, temp;",
            "    ",
            "    for (i = 0; i < n - 1; i++) {",
            "        minIndex = i; // 假定未排序部分的第一个元素是最小的",
            "        for (j = i + 1; j < n; j++) {",
            "            // 寻找未排序部分中的最小元素的索引",
            "            if (arr[j] < arr[minIndex]) {",
            "                minIndex = j;",
            "            }",
            "        }",
            "",
            "        // 交换未排序部分的第一个元素和最小元素",
            "        temp = arr[i];",
            "        arr[i] = arr[minIndex];",
            "        arr[minIndex] = temp;",
            "    }",
            "}"
        ],
        "description": "Code snippet for selectionSort"
    },
    "selectionSortCn": {
        "prefix": "数组选择排序",
        "body": [
            "// 选择排序函数",
            "void selectionSort(int arr[], int n) {",
            "    int i, j, minIndex, temp;",
            "    ",
            "    for (i = 0; i < n - 1; i++) {",
            "        minIndex = i; // 假定未排序部分的第一个元素是最小的",
            "        for (j = i + 1; j < n; j++) {",
            "            // 寻找未排序部分中的最小元素的索引",
            "            if (arr[j] < arr[minIndex]) {",
            "                minIndex = j;",
            "            }",
            "        }",
            "",
            "        // 交换未排序部分的第一个元素和最小元素",
            "        temp = arr[i];",
            "        arr[i] = arr[minIndex];",
            "        arr[minIndex] = temp;",
            "    }",
            "}"
        ],
        "description": "Code snippet for selectionSort"
    },
    "quickSort": {
        "prefix": "arrQuickSort",
        "body": [
            "// 交换数组中两个元素的值",
            "void swap(int *a, int *b) {",
            "    int temp = *a;",
            "    *a = *b;",
            "    *b = temp;",
            "}",
            "",
            "// 分割数组，并返回分割点的索引",
            "int partition(int arr[], int low, int high) {",
            "    int pivot = arr[high]; // 选择最后一个元素作为枢纽元素",
            "    int i = low - 1; // 初始化较小元素的索引",
            "",
            "    for (int j = low; j <= high - 1; j++) {",
            "        if (arr[j] <= pivot) {",
            "            i++; // 较小元素的索引增加",
            "            swap(&arr[i], &arr[j]);",
            "        }",
            "    }",
            "",
            "    swap(&arr[i + 1], &arr[high]);",
            "    return i + 1;",
            "}",
            "",
            "// 快速排序函数",
            "void quickSort(int arr[], int low, int high) {",
            "    if (low < high) {",
            "        // 找到分割点的索引",
            "        int pi = partition(arr, low, high);",
            "",
            "        // 递归对分割点左边和右边的子数组进行排序",
            "        quickSort(arr, low, pi - 1);",
            "        quickSort(arr, pi + 1, high);",
            "    }",
            "}"
        ],
        "description": "Code snippet for quickSort"
    },
    "quickSortCn": {
        "prefix": "数组快速排序",
        "body": [
            "// 交换数组中两个元素的值",
            "void swap(int *a, int *b) {",
            "    int temp = *a;",
            "    *a = *b;",
            "    *b = temp;",
            "}",
            "",
            "// 分割数组，并返回分割点的索引",
            "int partition(int arr[], int low, int high) {",
            "    int pivot = arr[high]; // 选择最后一个元素作为枢纽元素",
            "    int i = low - 1; // 初始化较小元素的索引",
            "",
            "    for (int j = low; j <= high - 1; j++) {",
            "        if (arr[j] <= pivot) {",
            "            i++; // 较小元素的索引增加",
            "            swap(&arr[i], &arr[j]);",
            "        }",
            "    }",
            "",
            "    swap(&arr[i + 1], &arr[high]);",
            "    return i + 1;",
            "}",
            "",
            "// 快速排序函数",
            "void quickSort(int arr[], int low, int high) {",
            "    if (low < high) {",
            "        // 找到分割点的索引",
            "        int pi = partition(arr, low, high);",
            "",
            "        // 递归对分割点左边和右边的子数组进行排序",
            "        quickSort(arr, low, pi - 1);",
            "        quickSort(arr, pi + 1, high);",
            "    }",
            "}"
        ],
        "description": "Code snippet for quickSortCn"
    },
    "arrfindDuplicates": {
        "prefix": "arrfindDuplicates",
        "body": [
            "void findDuplicates(int arr[], int n) {",
            "    int i, j;",
            "    printf(重复元素：%d);",
            "    ",
            "    for (i = 0; i < n - 1; i++) {",
            "        for (j = i + 1; j < n; j++) {",
            "            if (arr[i] == arr[j]) {",
            "                printf(%d, arr[i]);",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Code snippet for arrfindDuplicates"
    },
    "arrfindDuplicatesCn": {
        "prefix": "数组查找重复元素",
        "body": [
            "void findDuplicates(int arr[], int n) {",
            "    int i, j;",
            "    printf(重复元素：%d);",
            "    ",
            "    for (i = 0; i < n - 1; i++) {",
            "        for (j = i + 1; j < n; j++) {",
            "            if (arr[i] == arr[j]) {",
            "                printf(%d, arr[i]);",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Code snippet for arrfindDuplicatesCn"
    },
    "findMaxAndMin": {
        "prefix": "arrFindMaxAndMin",
        "body": [
            "// 函数用于查找数组的最大值和最小值",
            "void findMaxAndMin(int arr[], int n, int *max, int *min) {",
            "    *max = *min = arr[0]; // 初始化最大值和最小值为数组的第一个元素",
            "",
            "    for (int i = 1; i < n; i++) {",
            "        if (arr[i] > *max) {",
            "            *max = arr[i]; // 更新最大值",
            "        }",
            "        if (arr[i] < *min) {",
            "            *min = arr[i]; // 更新最小值",
            "        }",
            "    }",
            "}"
        ],
        "description": "Code snippet for findMaxAndMin"
    },
    "findMaxAndMinCn": {
        "prefix": "数组查找最大值和最小值",
        "body": [
            "// 函数用于查找数组的最大值和最小值",
            "void findMaxAndMin(int arr[], int n, int *max, int *min) {",
            "    *max = *min = arr[0]; // 初始化最大值和最小值为数组的第一个元素",
            "",
            "    for (int i = 1; i < n; i++) {",
            "        if (arr[i] > *max) {",
            "            *max = arr[i]; // 更新最大值",
            "        }",
            "        if (arr[i] < *min) {",
            "            *min = arr[i]; // 更新最小值",
            "        }",
            "    }",
            "}"
        ],
        "description": "Code snippet for findMaxAndMin"
    },
    "mergeSortedArrays": {
        "prefix": "arrMergeSortedArrays",
        "body": [
            "void mergeSortedArrays(int arr1[], int m, int arr2[], int n, int merged[]) {",
            "    int i = 0; // 用于遍历 arr1",
            "    int j = 0; // 用于遍历 arr2",
            "    int k = 0; // 用于遍历 merged",
            "",
            "    while (i < m && j < n) {",
            "        if (arr1[i] < arr2[j]) {",
            "            merged[k++] = arr1[i++];",
            "        } else {",
            "            merged[k++] = arr2[j++];",
            "        }",
            "    }",
            "",
            "    // 将剩余元素复制到 merged 数组中",
            "    while (i < m) {",
            "        merged[k++] = arr1[i++];",
            "    }",
            "",
            "    while (j < n) {",
            "        merged[k++] = arr2[j++];",
            "    }",
            "}"
        ],
        "description": "Code snippet for arrMergeSortedArrays"
    },
    "mergeSortedArraysCN": {
        "prefix": "数组合并两个有序数组",
        "body": [
            "void mergeSortedArrays(int arr1[], int m, int arr2[], int n, int merged[]) {",
            "    int i = 0; // 用于遍历 arr1",
            "    int j = 0; // 用于遍历 arr2",
            "    int k = 0; // 用于遍历 merged",
            "",
            "    while (i < m && j < n) {",
            "        if (arr1[i] < arr2[j]) {",
            "            merged[k++] = arr1[i++];",
            "        } else {",
            "            merged[k++] = arr2[j++];",
            "        }",
            "    }",
            "",
            "    // 将剩余元素复制到 merged 数组中",
            "    while (i < m) {",
            "        merged[k++] = arr1[i++];",
            "    }",
            "",
            "    while (j < n) {",
            "        merged[k++] = arr2[j++];",
            "    }",
            "}"
        ],
        "description": "Code snippet for arrMergeSortedArrays"
    },
    "countElement": {
        "prefix": "arrCountElement",
        "body": [
            "int countElement(int arr[], int n, int target) {",
            "    int count = 0; // 初始化计数器为0",
            "",
            "    // 遍历数组并计数目标元素的出现次数",
            "    for (int i = 0; i < n; i++) {",
            "        if (arr[i] == target) {",
            "            count++;",
            "        }",
            "    }",
            "",
            "    return count;",
            "}"
        ],
        "description": "Code snippet for arrCountElement"
    },
    "countElementCn": {
        "prefix": "数组计数元素出现次数",
        "body": [
            "int countElement(int arr[], int n, int target) {",
            "    int count = 0; // 初始化计数器为0",
            "",
            "    // 遍历数组并计数目标元素的出现次数",
            "    for (int i = 0; i < n; i++) {",
            "        if (arr[i] == target) {",
            "            count++;",
            "        }",
            "    }",
            "",
            "    return count;",
            "}"
        ],
        "description": "Code snippet for arrCountElement"
    },
    "arrElemSum": {
        "prefix": "arrElemSum",
        "body": [
            " int arrElemSum(int arr[], int n)",
            " {",
            "    int sum = 0; // 初始化总和为0",
            "",
            "    // 遍历数组并计算总和",
            "    for (int i = 0; i < n; i++) {",
            "        sum += arr[i];",
            "    }",
            "    return sum;",
            " }"
        ],
        "description": "Code snippet for arrElemSum"
    },
    "arrElemSumCn": {
        "prefix": "数组求和",
        "body": [
            " int arrElemSum(int arr[], int n)",
            " {",
            "    int sum = 0; // 初始化总和为0",
            "",
            "    // 遍历数组并计算总和",
            "    for (int i = 0; i < n; i++) {",
            "        sum += arr[i];",
            "    }",
            "    return sum;",
            " }"
        ],
        "description": "Code snippet for arrElemSum"
    },
    "calculateMedian": {
        "prefix": "arrCalculateMedian",
        "body": [
            "// 比较函数，用于qsort排序",
            "int compare(const void *a, const void *b) {",
            "    return (*(int*)a - *(int*)b);",
            "}",
            "",
            "// 计算中位数的函数",
            "int calculateMedian(int data[], int n) {",
            "    // 对数据进行排序",
            "    qsort(data, n, sizeof(int), compare);",
            "",
            "    // 中位数的位置取决于数据的个数",
            "    int median;",
            "    if (n % 2 == 0) {",
            "        median = (data[n / 2 - 1] + data[n / 2]) / 2;",
            "    } else {",
            "        median = data[n / 2];",
            "    }",
            "",
            "    return median;",
            "}"
        ],
        "description": "Code snippet for arrCalculateMedian"
    },
    "calculateMedianCn": {
        "prefix": "数组查找中位数",
        "body": [
            "// 比较函数，用于qsort排序",
            "int compare(const void *a, const void *b) {",
            "    return (*(int*)a - *(int*)b);",
            "}",
            "",
            "// 计算中位数的函数",
            "int calculateMedian(int data[], int n) {",
            "    // 对数据进行排序",
            "    qsort(data, n, sizeof(int), compare);",
            "",
            "    // 中位数的位置取决于数据的个数",
            "    int median;",
            "    if (n % 2 == 0) {",
            "        median = (data[n / 2 - 1] + data[n / 2]) / 2;",
            "    } else {",
            "        median = data[n / 2];",
            "    }",
            "",
            "    return median;",
            "}"
        ],
        "description": "Code snippet for arrCalculateMedian"
    },
    "runStateMachine": {
        "prefix": "runStateMachine",
        "body": [
            "// 定义状态枚举",
            "enum State {",
            "    STATE_IDLE,",
            "    STATE_START,",
            "    STATE_RUNNING,",
            "    STATE_PAUSE,",
            "    STATE_RESUME,",
            "    STATE_STOP",
            "};",
            "",
            "// 定义状态机函数",
            "enum State runStateMachine(enum State currentState) {",
            "    switch (currentState) {",
            "        case STATE_IDLE:",
            "            return STATE_START;",
            "",
            "        case STATE_START:",
            "            return STATE_RUNNING;",
            "",
            "        case STATE_RUNNING:",
            "            // 这里可以添加运行时的操作",
            "            return STATE_PAUSE;",
            "",
            "        case STATE_PAUSE:",
            "            // 这里可以添加暂停时的操作",
            "            return STATE_RESUME;",
            "",
            "        case STATE_RESUME:",
            "            // 这里可以添加恢复时的操作",
            "            return STATE_RUNNING;",
            "",
            "        case STATE_STOP:",
            "            // 这里可以添加停止时的操作",
            "            return STATE_IDLE;",
            "    }",
            "",
            "    // 默认情况下返回当前状态",
            "    return currentState;",
            "}"
        ],
        "description": "Code snippet for runStateMachine"
    },
    "runStateMachineCn": {
        "prefix": "状态机",
        "body": [
            "// 定义状态枚举",
            "enum State {",
            "    STATE_IDLE,",
            "    STATE_START,",
            "    STATE_RUNNING,",
            "    STATE_PAUSE,",
            "    STATE_RESUME,",
            "    STATE_STOP",
            "};",
            "",
            "// 定义状态机函数",
            "enum State runStateMachine(enum State currentState) {",
            "    switch (currentState) {",
            "        case STATE_IDLE:",
            "            return STATE_START;",
            "",
            "        case STATE_START:",
            "            return STATE_RUNNING;",
            "",
            "        case STATE_RUNNING:",
            "            // 这里可以添加运行时的操作",
            "            return STATE_PAUSE;",
            "",
            "        case STATE_PAUSE:",
            "            // 这里可以添加暂停时的操作",
            "            return STATE_RESUME;",
            "",
            "        case STATE_RESUME:",
            "            // 这里可以添加恢复时的操作",
            "            return STATE_RUNNING;",
            "",
            "        case STATE_STOP:",
            "            // 这里可以添加停止时的操作",
            "            return STATE_IDLE;",
            "    }",
            "",
            "    // 默认情况下返回当前状态",
            "    return currentState;",
            "}"
        ],
        "description": "Code snippet for runStateMachine"
    },
    "removeNthFromEnd": {
        "prefix": "listRemoveNthFromEnd",
        "body": [
            "/**",
            " * Definition for singly-linked list.",
            " * struct ListNode {",
            " *     int val;",
            " *     struct ListNode *next;",
            " * };",
            " */",
            "",
            "struct ListNode *removeNthFromEnd(struct ListNode *head, int n) {",
            "    struct ListNode entry, *p_free, *p = head;",
            "    int i, sz = 0;",
            "    entry.next = head;",
            "    while (p != NULL) {",
            "        p = p->next;",
            "        sz++;",
            "    }",
            "    for (i = 0, p = &entry; i < sz - n; i++, p = p -> next)",
            "    ;",
            "    p_free = p->next;",
            "    if (n != 1) {",
            "        p->next = p->next->next;",
            "    } else {",
            "        p->next = NULL;",
            "    }",
            "    free(p_free);",
            "    return entry.next;",
            "}"
        ],
        "description": "Code snippet for listRemoveNthFromEnd"
    },
    "removeNthFromEndCn": {
        "prefix": "链表删除倒数第N个节点",
        "body": [
            "/**",
            " * Definition for singly-linked list.",
            " * struct ListNode {",
            " *     int val;",
            " *     struct ListNode *next;",
            " * };",
            " */",
            "",
            "struct ListNode *removeNthFromEnd(struct ListNode *head, int n) {",
            "    struct ListNode entry, *p_free, *p = head;",
            "    int i, sz = 0;",
            "    entry.next = head;",
            "    while (p != NULL) {",
            "        p = p->next;",
            "        sz++;",
            "    }",
            "    for (i = 0, p = &entry; i < sz - n; i++, p = p -> next)",
            "    ;",
            "    p_free = p->next;",
            "    if (n != 1) {",
            "        p->next = p->next->next;",
            "    } else {",
            "        p->next = NULL;",
            "    }",
            "    free(p_free);",
            "    return entry.next;",
            "}"
        ],
        "description": "Code snippet for listRemoveNthFromEnd"
    },
    "reverseBits": {
        "prefix": "reverseBits",
        "body": [
            "uint32_t reverseBits(uint32_t n)",
            "{",
            "    uint TotalBits = 32;",
            "    uint32_t reverse_int = 0;  // stored in memory as 32 bits, each bit valued 0",
            "    uint i;",
            "    for (i = 0; i < TotalBits; i++)",
            "    {",
            "        if ((n & (UINT32_C(1)",
            "                  << i)))  // if the bit on the ith position of 32 bit input is",
            "                           // 1, then proceed Further note the use of UINT32_C",
            "                           // to convert 1 to unsigned 32 bit int, since just 1",
            "                           // is treated as int which cannot be shifted left",
            "                           // more than 30 times",
            "            reverse_int =",
            "                reverse_int |",
            "                (UINT32_C(1)",
            "                 << (TotalBits - 1 -",
            "                     i));  // Convert the ith bit from the end in reverse_int",
            "                           // from 0 to 1, if ith bit from beginning in n is 1",
            "                           // This is achieved by using bitwise OR on",
            "                           // reverse_int (where ith bit from end is currently",
            "                           // 0) and 1 shifted left 31 - i bits (to ith bit from",
            "                           // the end)",
            "    }",
            "    return reverse_int;",
            "}"
        ],
        "description": "Code snippet for reverseBits"
    },
    "reverseBitsCN": {
        "prefix": "位反转uint32",
        "body": [
            "uint32_t reverseBits(uint32_t n)",
            "{",
            "    uint TotalBits = 32;",
            "    uint32_t reverse_int = 0;  // stored in memory as 32 bits, each bit valued 0",
            "    uint i;",
            "    for (i = 0; i < TotalBits; i++)",
            "    {",
            "        if ((n & (UINT32_C(1)",
            "                  << i)))  // if the bit on the ith position of 32 bit input is",
            "                           // 1, then proceed Further note the use of UINT32_C",
            "                           // to convert 1 to unsigned 32 bit int, since just 1",
            "                           // is treated as int which cannot be shifted left",
            "                           // more than 30 times",
            "            reverse_int =",
            "                reverse_int |",
            "                (UINT32_C(1)",
            "                 << (TotalBits - 1 -",
            "                     i));  // Convert the ith bit from the end in reverse_int",
            "                           // from 0 to 1, if ith bit from beginning in n is 1",
            "                           // This is achieved by using bitwise OR on",
            "                           // reverse_int (where ith bit from end is currently",
            "                           // 0) and 1 shifted left 31 - i bits (to ith bit from",
            "                           // the end)",
            "    }",
            "    return reverse_int;",
            "}"
        ],
        "description": "Code snippet for reverseBits"
    },
    "hammingWeight": {
        "prefix": "hammingWeight",
        "body": [
            "int hammingWeight(uint32_t n)",
            "{",
            "    int TotalBits = 32;",
            "    int i, weight = 0;",
            "    for (i = 0; i < TotalBits; i++)",
            "    {",
            "        if (n &",
            "            (UINT32_C(1)",
            "             << i))  // if the bit on the ith position of 32 bit input is 1,",
            "                     // then proceed Further note the use of UINT32_C to",
            "                     // convert 1 to unsigned 32 bit int, as just 1 is treated",
            "                     // as int which cannot be shifted left more than 30 times",
            "            weight += 1;",
            "    }",
            "    return weight;",
            "}"
        ],
        "description": "Code snippet for hammingWeight"
    },
    "hammingWeightCN": {
        "prefix": "求二进制1的个数",
        "body": [
            "int hammingWeight(uint32_t n)",
            "{",
            "    int TotalBits = 32;",
            "    int i, weight = 0;",
            "    for (i = 0; i < TotalBits; i++)",
            "    {",
            "        if (n &",
            "            (UINT32_C(1)",
            "             << i))  // if the bit on the ith position of 32 bit input is 1,",
            "                     // then proceed Further note the use of UINT32_C to",
            "                     // convert 1 to unsigned 32 bit int, as just 1 is treated",
            "                     // as int which cannot be shifted left more than 30 times",
            "            weight += 1;",
            "    }",
            "    return weight;",
            "}"
        ],
        "description": "Code snippet for hammingWeight"
    },
    "isValidBrackets": {
        "prefix": "isValidBrackets",
        "body": [
            "bool isValidBrackets(char *s)",
            "{",
            "    int i, k = 0, len = strlen(s);",
            "    char *store = calloc(len, sizeof(char));",
            "",
            "    for (i = 0; s[i] != 0; i++)",
            "    {",
            "        switch (s[i])",
            "        {",
            "        case '(':",
            "        case '{':",
            "        case '[':",
            "            store[k++] = s[i];",
            "            break;",
            "        case ')':",
            "            if (k < 1 || store[--k] != '(')",
            "                goto out;",
            "            break;",
            "        case '}':",
            "            if (k < 1 || store[--k] != '{')",
            "                goto out;",
            "            break;",
            "        case ']':",
            "            if (k < 1 || store[--k] != '[')",
            "                goto out;",
            "            break;",
            "        }",
            "    }",
            "out:",
            "    free(store);",
            "    return s[i] == '0' && k == 0;",
            "}"
        ],
        "description": "Code snippet for isValidBrackets"
    },
    "isValidBracketsCN": {
        "prefix": "检查括号配对",
        "body": [
            "bool isValidBrackets(char *s)",
            "{",
            "    int i, k = 0, len = strlen(s);",
            "    char *store = calloc(len, sizeof(char));",
            "",
            "    for (i = 0; s[i] != 0; i++)",
            "    {",
            "        switch (s[i])",
            "        {",
            "        case '(':",
            "        case '{':",
            "        case '[':",
            "            store[k++] = s[i];",
            "            break;",
            "        case ')':",
            "            if (k < 1 || store[--k] != '(')",
            "                goto out;",
            "            break;",
            "        case '}':",
            "            if (k < 1 || store[--k] != '{')",
            "                goto out;",
            "            break;",
            "        case ']':",
            "            if (k < 1 || store[--k] != '[')",
            "                goto out;",
            "            break;",
            "        }",
            "    }",
            "out:",
            "    free(store);",
            "    return s[i] == '0' && k == 0;",
            "}"
        ],
        "description": "Code snippet for isValidBrackets"
    },
    "rangeBitwiseAnd": {
        "prefix": "bitwiseAnd",
        "body": [
            "int rangeBitwiseAnd(int m, int n)",
            "{",
            "    while (m < n)",
            "    {",
            "        n &= n - 1;",
            "    }",
            "    return n;",
            "}"
        ],
        "description": "Code snippet for rangeBitwiseAnd statement"
    },
    "rangeBitwiseAndCN": {
        "prefix": "位与",
        "body": [
            "int rangeBitwiseAnd(int m, int n)",
            "{",
            "    while (m < n)",
            "    {",
            "        n &= n - 1;",
            "    }",
            "    return n;",
            "}"
        ],
        "description": "Code snippet for rangeBitwiseAndCN statement"
    },
    "listRemoveValElements": {
        "prefix": "listRemoveValElements",
        "body": [
            "struct ListNode *removeElements(struct ListNode *head, int val)",
            "{",
            "    if (head == NULL)",
            "        return NULL;",
            "    if (head->val == val)",
            "    {",
            "        return removeElements(head->next, val);",
            "    }",
            "    else",
            "    {",
            "        head->next = removeElements(head->next, val);",
            "    }",
            "    return head;",
            "}"
        ],
        "description": "Code snippet for listRemoveValElements statement"
    },
    "listRemoveValElementsCN": {
        "prefix": "链表删除给定值",
        "body": [
            "struct ListNode *removeElements(struct ListNode *head, int val)",
            "{",
            "    if (head == NULL)",
            "        return NULL;",
            "    if (head->val == val)",
            "    {",
            "        return removeElements(head->next, val);",
            "    }",
            "    else",
            "    {",
            "        head->next = removeElements(head->next, val);",
            "    }",
            "    return head;",
            "}"
        ],
        "description": "Code snippet for listRemoveValElements statement"
    },
    "listReverseList": {
        "prefix": "listReverseList",
        "body": [
            "/**",
            " * Definition for singly-linked list.",
            " * struct ListNode {",
            " *     int val;",
            " *     struct ListNode *next;",
            " * };",
            " */",
            "",
            "struct ListNode *reverseList(struct ListNode *head)",
            "{",
            "    struct ListNode *res = NULL;",
            "    while (head)",
            "    {",
            "        struct ListNode *pre_node = head;",
            "        head = head->next;",
            "        pre_node->next = res;",
            "        res = pre_node;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Code snippet for listReverseList statement"
    },
    "listReverseListCN": {
        "prefix": "链表反转",
        "body": [
            "/**",
            " * Definition for singly-linked list.",
            " * struct ListNode {",
            " *     int val;",
            " *     struct ListNode *next;",
            " * };",
            " */",
            "",
            "struct ListNode *reverseList(struct ListNode *head)",
            "{",
            "    struct ListNode *res = NULL;",
            "    while (head)",
            "    {",
            "        struct ListNode *pre_node = head;",
            "        head = head->next;",
            "        pre_node->next = res;",
            "        res = pre_node;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Code snippet for listReverseList statement"
    },
    "uniqueOccurrences": {
        "prefix": "arrUniqueOccurrences",
        "body": [
            "#define MAP_SIZE 2048",
            "",
            "int cmpvalue(const void *a, const void *b) { return *(int *)b - *(int *)a; }",
            "bool uniqueOccurrences(int *arr, int arrSize)",
            "{",
            "    int *map = calloc(MAP_SIZE, sizeof(int));",
            "    int i;",
            "    for (i = 0; i < arrSize; i++)",
            "    {",
            "        if (arr[i] < 0)",
            "            map[arr[i] + MAP_SIZE / 2] += 1;",
            "        else",
            "            map[arr[i]] += 1;",
            "    }",
            "    /* number of occurrences is sorted by decreasing order",
            "       Ex: 3 2 1 0 0 0 0 */",
            "    qsort(map, MAP_SIZE, sizeof(int), cmpvalue);",
            "    i = 0;",
            "    while (map[i])",
            "    {",
            "        if (map[i] == map[i + 1])",
            "            return 0;",
            "        i++;",
            "    }",
            "    return 1;",
            "}"
        ],
        "description": "Code snippet for uniqueOccurrences statement"
    },
    "uniqueOccurrencesCn": {
        "prefix": "数组元素是否唯一",
        "body": [
            "#define MAP_SIZE 2048",
            "",
            "int cmpvalue(const void *a, const void *b) { return *(int *)b - *(int *)a; }",
            "bool uniqueOccurrences(int *arr, int arrSize)",
            "{",
            "    int *map = calloc(MAP_SIZE, sizeof(int));",
            "    int i;",
            "    for (i = 0; i < arrSize; i++)",
            "    {",
            "        if (arr[i] < 0)",
            "            map[arr[i] + MAP_SIZE / 2] += 1;",
            "        else",
            "            map[arr[i]] += 1;",
            "    }",
            "    /* number of occurrences is sorted by decreasing order",
            "       Ex: 3 2 1 0 0 0 0 */",
            "    qsort(map, MAP_SIZE, sizeof(int), cmpvalue);",
            "    i = 0;",
            "    while (map[i])",
            "    {",
            "        if (map[i] == map[i + 1])",
            "            return 0;",
            "        i++;",
            "    }",
            "    return 1;",
            "}"
        ],
        "description": "Code snippet for uniqueOccurrences statement"
    },
    "MaxSubarray": {
        "prefix": "arrMaxSubarray",
        "body": [
            "int maxcmp(int a, int b) { return (a >= b) ? a : b; }",
            "",
            "/* max subarray problem by using Kadane's Algorithm",
            " */",
            "int maxProfit(int *prices, int pricesSize)",
            "{",
            "    /* maxCur: current maximum",
            "     * maxSoFar: found maximum for subarray so far",
            "     */",
            "    int maxCur = 0, maxSoFar = 0;",
            "    for (int i = 1; i < pricesSize; i++)",
            "    {",
            "        maxCur = maxcmp(0, maxCur + prices[i] - prices[i - 1]);",
            "        maxSoFar = maxcmp(maxSoFar, maxCur);",
            "    }",
            "    return maxSoFar;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "MaxSubarrayCn": {
        "prefix": "数组最大子数组和",
        "body": [
            "int maxcmp(int a, int b) { return (a >= b) ? a : b; }",
            "",
            "/* max subarray problem by using Kadane's Algorithm",
            " */",
            "int maxProfit(int *prices, int pricesSize)",
            "{",
            "    /* maxCur: current maximum",
            "     * maxSoFar: found maximum for subarray so far",
            "     */",
            "    int maxCur = 0, maxSoFar = 0;",
            "    for (int i = 1; i < pricesSize; i++)",
            "    {",
            "        maxCur = maxcmp(0, maxCur + prices[i] - prices[i - 1]);",
            "        maxSoFar = maxcmp(maxSoFar, maxCur);",
            "    }",
            "    return maxSoFar;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "isPalindrome": {
        "prefix": "strIsPalindrome",
        "body": [
            "bool isPalindrome(char *s)",
            "{",
            "    int start = 0, end = strlen(s) - 1;",
            "    while (start < end)",
            "    {",
            "        if (!isalpha(s[start]) && !isalnum(s[start]))",
            "        {",
            "            start++;",
            "        }",
            "        else if (!isalpha(s[end]) && !isalnum(s[end]))",
            "        {",
            "            end--;",
            "        }",
            "        else",
            "        {",
            "            char c1 = tolower(s[start]);",
            "            char c2 = tolower(s[end]);",
            "            if (c1 != c2)",
            "                return 0;",
            "            start++;",
            "            end--;",
            "        }",
            "    }",
            "    return 1;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "isPalindromeCN": {
        "prefix": "字符串回文判断",
        "body": [
            "bool isPalindrome(char *s)",
            "{",
            "    int start = 0, end = strlen(s) - 1;",
            "    while (start < end)",
            "    {",
            "        if (!isalpha(s[start]) && !isalnum(s[start]))",
            "        {",
            "            start++;",
            "        }",
            "        else if (!isalpha(s[end]) && !isalnum(s[end]))",
            "        {",
            "            end--;",
            "        }",
            "        else",
            "        {",
            "            char c1 = tolower(s[start]);",
            "            char c2 = tolower(s[end]);",
            "            if (c1 != c2)",
            "                return 0;",
            "            start++;",
            "            end--;",
            "        }",
            "    }",
            "    return 1;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "romanToInt": {
        "prefix": "strRomanToInt",
        "body": [
            "int romanToInt(char *s)",
            "{",
            "    int romanToInt = 0;",
            "    for (int i = 0; i < strlen(s); i++)",
            "    {",
            "        switch (s[i])",
            "        {",
            "        case 'I':",
            "            if (i + 1 < strlen(s))",
            "            {",
            "                if (s[i + 1] == 'V' || s[i + 1] == 'X')",
            "                {",
            "                    romanToInt -= 1;",
            "                    break;",
            "                }",
            "            }",
            "            romanToInt += 1;",
            "            break;",
            "        case 'V':",
            "            romanToInt += 5;",
            "            break;",
            "        case 'X':",
            "            if (i + 1 < strlen(s))",
            "            {",
            "                if (s[i + 1] == 'L' || s[i + 1] == 'C')",
            "                {",
            "                    romanToInt -= 10;",
            "                    break;",
            "                }",
            "            }",
            "            romanToInt += 10;",
            "            break;",
            "        case 'L':",
            "            romanToInt += 50;",
            "            break;",
            "        case 'C':",
            "            if (i + 1 < strlen(s))",
            "            {",
            "                if (s[i + 1] == 'D' || s[i + 1] == 'M')",
            "                {",
            "                    romanToInt -= 100;",
            "                    break;",
            "                }",
            "            }",
            "            romanToInt += 100;",
            "            break;",
            "        case 'D':",
            "            romanToInt += 500;",
            "            break;",
            "        case 'M':",
            "            romanToInt += 1000;",
            "            break;",
            "        default:",
            "            break;",
            "        }",
            "    }",
            "    return romanToInt;",
            "}"
        ],
        "description": "Code snippet for romanToInt statement"
    },
    "romanToIntCn": {
        "prefix": "字符串罗马数字转int",
        "body": [
            "int romanToInt(char *s)",
            "{",
            "    int romanToInt = 0;",
            "    for (int i = 0; i < strlen(s); i++)",
            "    {",
            "        switch (s[i])",
            "        {",
            "        case 'I':",
            "            if (i + 1 < strlen(s))",
            "            {",
            "                if (s[i + 1] == 'V' || s[i + 1] == 'X')",
            "                {",
            "                    romanToInt -= 1;",
            "                    break;",
            "                }",
            "            }",
            "            romanToInt += 1;",
            "            break;",
            "        case 'V':",
            "            romanToInt += 5;",
            "            break;",
            "        case 'X':",
            "            if (i + 1 < strlen(s))",
            "            {",
            "                if (s[i + 1] == 'L' || s[i + 1] == 'C')",
            "                {",
            "                    romanToInt -= 10;",
            "                    break;",
            "                }",
            "            }",
            "            romanToInt += 10;",
            "            break;",
            "        case 'L':",
            "            romanToInt += 50;",
            "            break;",
            "        case 'C':",
            "            if (i + 1 < strlen(s))",
            "            {",
            "                if (s[i + 1] == 'D' || s[i + 1] == 'M')",
            "                {",
            "                    romanToInt -= 100;",
            "                    break;",
            "                }",
            "            }",
            "            romanToInt += 100;",
            "            break;",
            "        case 'D':",
            "            romanToInt += 500;",
            "            break;",
            "        case 'M':",
            "            romanToInt += 1000;",
            "            break;",
            "        default:",
            "            break;",
            "        }",
            "    }",
            "    return romanToInt;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "singleNumber": {
        "prefix": "arrSingleNumber",
        "body": [
            "int singleNumber(int *nums, int numsSize)",
            "{",
            "    int i, result = 0;",
            "    for (i = 0; i < numsSize; i++)",
            "        result = result ^ nums[i];",
            "    return result;",
            "}"
        ],
        "description": "Code snippet for singleNumber statement"
    },
    "singleNumberCn": {
        "prefix": "数组只出现一次的数",
        "body": [
            "int singleNumber(int *nums, int numsSize)",
            "{",
            "    int i, result = 0;",
            "    for (i = 0; i < numsSize; i++)",
            "        result = result ^ nums[i];",
            "    return result;",
            "}"
        ],
        "description": "Code snippet for singleNumber statement"
    },
    "detectCycle": {
        "prefix": "listDetectCycle",
        "body": [
            "struct ListNode *detectCycle(struct ListNode *head)",
            "{",
            "    if (head == NULL || head->next == NULL)",
            "        return NULL;",
            "    struct ListNode *slow, *fast;",
            "    slow = fast = head;",
            "    while (fast && fast->next)",
            "    {",
            "        slow = slow->next;",
            "        fast = fast->next->next;",
            "        if (slow == fast)",
            "        {",
            "            struct ListNode *entry = head;",
            "            while (slow != entry)",
            "            {",
            "                slow = slow->next;",
            "                entry = entry->next;",
            "            }",
            "            return entry;",
            "        }",
            "    }",
            "    return NULL;",
            "}"
        ],
        "description": "Code snippet for listDetectCycle statement"
    },
    "detectCycleCn": {
        "prefix": "链表存在环",
        "body": [
            "struct ListNode *detectCycle(struct ListNode *head)",
            "{",
            "    if (head == NULL || head->next == NULL)",
            "        return NULL;",
            "    struct ListNode *slow, *fast;",
            "    slow = fast = head;",
            "    while (fast && fast->next)",
            "    {",
            "        slow = slow->next;",
            "        fast = fast->next->next;",
            "        if (slow == fast)",
            "        {",
            "            struct ListNode *entry = head;",
            "            while (slow != entry)",
            "            {",
            "                slow = slow->next;",
            "                entry = entry->next;",
            "            }",
            "            return entry;",
            "        }",
            "    }",
            "    return NULL;",
            "}"
        ],
        "description": "Code snippet for listDetectCycle statement"
    },
    "find2divideMin": {
        "prefix": "arr2divideFindMin",
        "body": [
            "int findMin(int *nums, int numsSize)",
            "{",
            "    int low = 0, high = numsSize - 1;",
            "    while (low < high)",
            "    {",
            "        int mid = low + (high - low) / 2;",
            "        /* minimum is on left side */",
            "        if (nums[mid] < nums[high])",
            "            high = mid;",
            "        /* minimum is on right side */",
            "        else",
            "            low = mid + 1;",
            "    }",
            "    return nums[low];",
            "}"
        ],
        "description": "Code snippet for arrFind2divideMin statement"
    },
    "find2divideMinCn": {
        "prefix": "数组二分法查找最小值",
        "body": [
            "int findMin(int *nums, int numsSize)",
            "{",
            "    int low = 0, high = numsSize - 1;",
            "    while (low < high)",
            "    {",
            "        int mid = low + (high - low) / 2;",
            "        /* minimum is on left side */",
            "        if (nums[mid] < nums[high])",
            "            high = mid;",
            "        /* minimum is on right side */",
            "        else",
            "            low = mid + 1;",
            "    }",
            "    return nums[low];",
            "}"
        ],
        "description": "Code snippet for arrFind2divideMin statement"
    },
    "threeSumClosest": {
        "prefix": "arrThreeSumClosest",
        "body": [
            "#include <stdlib.h> // for qsort()",
            "",
            "int cmp(const void* a, const void* b) {",
            "    const int *A = a, *B = b;",
            "    return (*A > *B) - (*A < *B);",
            "}",
            "",
            "int threeSumClosest(int* nums, int nums_size, int target) {",
            "    int i, j, k, result, sum3;",
            "    qsort(nums, nums_size, sizeof(int), cmp);",
            "    result = nums[0] + nums[1] + nums[2];",
            "    for (i = 0; i < nums_size - 2; i++) {",
            "        j = i + 1;",
            "        k = nums_size - 1;",
            "        while (j < k) {",
            "            sum3 = nums[i] + nums[j] + nums[k];",
            "            if (abs(target - sum3) < abs(target - result)) {",
            "                result = sum3;",
            "            }",
            "            if (sum3 < target) {",
            "                j++;",
            "            } else if (sum3 > target) {",
            "                k--;",
            "            } else {",
            "                return sum3;",
            "            }",
            "        }",
            "    }",
            "    return result;",
            "}"
        ],
        "description": "Code snippet for arrThreeSumClosest statement"
    },
    "threeSumClosestCn": {
        "prefix": "数组最接近目标的值",
        "body": [
            "#include <stdlib.h> // for qsort()",
            "",
            "int cmp(const void* a, const void* b) {",
            "    const int *A = a, *B = b;",
            "    return (*A > *B) - (*A < *B);",
            "}",
            "",
            "int threeSumClosest(int* nums, int nums_size, int target) {",
            "    int i, j, k, result, sum3;",
            "    qsort(nums, nums_size, sizeof(int), cmp);",
            "    result = nums[0] + nums[1] + nums[2];",
            "    for (i = 0; i < nums_size - 2; i++) {",
            "        j = i + 1;",
            "        k = nums_size - 1;",
            "        while (j < k) {",
            "            sum3 = nums[i] + nums[j] + nums[k];",
            "            if (abs(target - sum3) < abs(target - result)) {",
            "                result = sum3;",
            "            }",
            "            if (sum3 < target) {",
            "                j++;",
            "            } else if (sum3 > target) {",
            "                k--;",
            "            } else {",
            "                return sum3;",
            "            }",
            "        }",
            "    }",
            "    return result;",
            "}"
        ],
        "description": "Code snippet for arrThreeSumClosest statement"
    },
    "performFFT": {
        "prefix": "performFFT",
        "body": [
            "#include <fftw3.h>",
            "",
            "void performFFT(double* signal, int signalLength) {",
            "    fftw_complex* output;",
            "    fftw_plan plan;",
            "",
            "    // 分配傅里叶变换输出数组",
            "    output = (fftw_complex*)fftw_malloc(sizeof(fftw_complex) * signalLength);",
            "",
            "    // 创建傅里叶变换计划",
            "    plan = fftw_plan_dft_r2c_1d(signalLength, signal, output, FFTW_ESTIMATE);",
            "",
            "    // 执行傅里叶变换",
            "    fftw_execute(plan);",
            "",
            "    // 输出变换结果",
            "    for (int i = 0; i < signalLength; i++) {",
            "        printf",
            "    }",
            "",
            "    // 清理资源",
            "    fftw_destroy_plan(plan);",
            "    fftw_free(output);",
            "}"
        ],
        "description": "Code snippet for performFFT statement"
    },
    "performFFT": {
        "prefix": "傅里叶变换",
        "body": [
            "#include <fftw3.h>",
            "",
            "void performFFT(double* signal, int signalLength) {",
            "    fftw_complex* output;",
            "    fftw_plan plan;",
            "",
            "    // 分配傅里叶变换输出数组",
            "    output = (fftw_complex*)fftw_malloc(sizeof(fftw_complex) * signalLength);",
            "",
            "    // 创建傅里叶变换计划",
            "    plan = fftw_plan_dft_r2c_1d(signalLength, signal, output, FFTW_ESTIMATE);",
            "",
            "    // 执行傅里叶变换",
            "    fftw_execute(plan);",
            "",
            "    // 输出变换结果",
            "    for (int i = 0; i < signalLength; i++) {",
            "        printf",
            "    }",
            "",
            "    // 清理资源",
            "    fftw_destroy_plan(plan);",
            "    fftw_free(output);",
            "}"
        ],
        "description": "Code snippet for performFFT statement"
    },
    "KalmanFilter": {
        "prefix": "KalmanFilter",
        "body": [
            "#include <stdio.h>",
            "",
            "// 卡尔曼滤波器结构体",
            "typedef struct {",
            "    double x;  // 状态变量的估计",
            "    double P;  // 估计误差的协方差",
            "    double Q;  // 状态预测噪声的协方差",
            "    double R;  // 测量噪声的协方差",
            "} KalmanFilter;",
            "",
            "// 初始化卡尔曼滤波器",
            "void initKalmanFilter(KalmanFilter *kf, double initialX, double initialP, double processNoise, double measurementNoise) {",
            "    kf->x = initialX;",
            "    kf->P = initialP;",
            "    kf->Q = processNoise;",
            "    kf->R = measurementNoise;",
            "}",
            "",
            "// 更新卡尔曼滤波器",
            "void updateKalmanFilter(KalmanFilter *kf, double measurement) {",
            "    // 预测步骤",
            "    double x_pred = kf->x;",
            "    double P_pred = kf->P + kf->Q;",
            "",
            "    // 更新步骤",
            "    double K = P_pred / (P_pred + kf->R);",
            "    kf->x = x_pred + K * (measurement - x_pred);",
            "    kf->P = (1 - K) * P_pred;",
            "}",
            "",
            "int main() {",
            "    KalmanFilter kf;",
            "    double initialX = 0.0;",
            "    double initialP = 1.0;",
            "    double processNoise = 0.01;",
            "    double measurementNoise = 0.1;",
            "",
            "    // 初始化卡尔曼滤波器",
            "    initKalmanFilter(&kf, initialX, initialP, processNoise, measurementNoise);",
            "",
            "    // 模拟测量值",
            "    double measurements[] = {1.1, 1.2, 1.3, 1.4, 1.5};",
            "",
            "    for (int i = 0; i < sizeof(measurements) / sizeof(measurements[0]); i++) {",
            "        // 更新卡尔曼滤波器",
            "        updateKalmanFilter(&kf, measurements[i]);",
            "        printf",
            "    }",
            "",
            "    return 0;",
            "}",
            "在上面的示例中，我们首先定义了一个 KalmanFilter 结构体，该结构体包含卡尔曼滤波器的状态变量和参数。然后，我们编写了初始化和更新卡尔曼滤波器的函数，并在 main 函数中使用这些函数来执行卡尔曼滤波。卡尔曼滤波器的核心思想在于预测和更新步骤，其中预测步骤用于估计下一个状态，而更新步骤用于根据测量值来调整估计。这个示例是一个简单的一维线性卡尔曼滤波器，用于估计一维状态变量。",
            "",
            "",
            "",
            "",
            ""
        ],
        "description": "Code snippet for switch statement"
    },
    "KalmanFilter": {
        "prefix": "卡尔曼滤波器",
        "body": [
            "#include <stdio.h>",
            "",
            "// 卡尔曼滤波器结构体",
            "typedef struct {",
            "    double x;  // 状态变量的估计",
            "    double P;  // 估计误差的协方差",
            "    double Q;  // 状态预测噪声的协方差",
            "    double R;  // 测量噪声的协方差",
            "} KalmanFilter;",
            "",
            "// 初始化卡尔曼滤波器",
            "void initKalmanFilter(KalmanFilter *kf, double initialX, double initialP, double processNoise, double measurementNoise) {",
            "    kf->x = initialX;",
            "    kf->P = initialP;",
            "    kf->Q = processNoise;",
            "    kf->R = measurementNoise;",
            "}",
            "",
            "// 更新卡尔曼滤波器",
            "void updateKalmanFilter(KalmanFilter *kf, double measurement) {",
            "    // 预测步骤",
            "    double x_pred = kf->x;",
            "    double P_pred = kf->P + kf->Q;",
            "",
            "    // 更新步骤",
            "    double K = P_pred / (P_pred + kf->R);",
            "    kf->x = x_pred + K * (measurement - x_pred);",
            "    kf->P = (1 - K) * P_pred;",
            "}",
            "",
            "int main() {",
            "    KalmanFilter kf;",
            "    double initialX = 0.0;",
            "    double initialP = 1.0;",
            "    double processNoise = 0.01;",
            "    double measurementNoise = 0.1;",
            "",
            "    // 初始化卡尔曼滤波器",
            "    initKalmanFilter(&kf, initialX, initialP, processNoise, measurementNoise);",
            "",
            "    // 模拟测量值",
            "    double measurements[] = {1.1, 1.2, 1.3, 1.4, 1.5};",
            "",
            "    for (int i = 0; i < sizeof(measurements) / sizeof(measurements[0]); i++) {",
            "        // 更新卡尔曼滤波器",
            "        updateKalmanFilter(&kf, measurements[i]);",
            "        printf",
            "    }",
            "",
            "    return 0;",
            "}",
            "在上面的示例中，我们首先定义了一个 KalmanFilter 结构体，该结构体包含卡尔曼滤波器的状态变量和参数。然后，我们编写了初始化和更新卡尔曼滤波器的函数，并在 main 函数中使用这些函数来执行卡尔曼滤波。卡尔曼滤波器的核心思想在于预测和更新步骤，其中预测步骤用于估计下一个状态，而更新步骤用于根据测量值来调整估计。这个示例是一个简单的一维线性卡尔曼滤波器，用于估计一维状态变量。",
            "",
            "",
            "",
            "",
            ""
        ],
        "description": "Code snippet for switch statement"
    },
    "majorityElement": {
        "prefix": "arrMajorityElement",
        "body": [
            "/* Boyer-Moore Majority Vote Algorithm",
            " * http://www.cs.utexas.edu/~moore/best-ideas/mjrty/ */",
            "int majorityElement(int *nums, int numsSize)",
            "{",
            "    int count = 1;",
            "    int majorNum = nums[0];",
            "    for (int i = 1; i < numsSize; i++)",
            "    {",
            "        if (count == 0)",
            "        {",
            "            majorNum = nums[i];",
            "            count++;",
            "        }",
            "        else if (majorNum == nums[i])",
            "            count++;",
            "        else",
            "            count--;",
            "    }",
            "    return majorNum;",
            "}"
        ],
        "description": "Code snippet for arrMajorityElement statement"
    },
    "majorityElementCn": {
        "prefix": "数组多数投票算法",
        "body": [
            "/* Boyer-Moore Majority Vote Algorithm",
            " * http://www.cs.utexas.edu/~moore/best-ideas/mjrty/ */",
            "int majorityElement(int *nums, int numsSize)",
            "{",
            "    int count = 1;",
            "    int majorNum = nums[0];",
            "    for (int i = 1; i < numsSize; i++)",
            "    {",
            "        if (count == 0)",
            "        {",
            "            majorNum = nums[i];",
            "            count++;",
            "        }",
            "        else if (majorNum == nums[i])",
            "            count++;",
            "        else",
            "            count--;",
            "    }",
            "    return majorNum;",
            "}"
        ],
        "description": "Code snippet for arrMajorityElement statement"
    },
    "arrMaximumUniqueSubarray": {
        "prefix": "arrMaximumUniqueSubarray",
        "body": [
            "/ Window sliding. Runtime: O(n), Space: O(n)",
            "int maximumUniqueSubarray(int* nums, int numsSize){",
            "    short* numsSet = (short*)calloc(10001, sizeof(short));",
            "    numsSet[nums[0]] = 1;",
            "",
            "    int maxSum = nums[0];",
            "",
            "    int windowSumm = maxSum;",
            "    int leftIndex = 0;",
            "    ",
            "    int num = 0;",
            "    for(int i = 1; i < numsSize; i++){",
            "        num = nums[i];",
            "        while (numsSet[num] != 0){",
            "            numsSet[nums[leftIndex]] = 0;",
            "            windowSumm -= nums[leftIndex];",
            "            leftIndex++;",
            "        }",
            "        ",
            "        numsSet[num] = 1;",
            "        windowSumm += num;",
            "            ",
            "        if (maxSum < windowSumm){",
            "            maxSum = windowSumm;",
            "        }",
            "    }",
            "    ",
            "    return maxSum;",
            "}"
        ],
        "description": "Code snippet for arrMaximumUniqueSubarray statement"
    },
    "arrMaximumUniqueSubarrayCn": {
        "prefix": "数组查找数组中的具有最大唯一元素和的子数组",
        "body": [
            "/ 窗口滑动.Window sliding. Runtime: O(n), Space: O(n)",
            "int maximumUniqueSubarray(int* nums, int numsSize){",
            "    short* numsSet = (short*)calloc(10001, sizeof(short));",
            "    numsSet[nums[0]] = 1;",
            "",
            "    int maxSum = nums[0];",
            "",
            "    int windowSumm = maxSum;",
            "    int leftIndex = 0;",
            "    ",
            "    int num = 0;",
            "    for(int i = 1; i < numsSize; i++){",
            "        num = nums[i];",
            "        while (numsSet[num] != 0){",
            "            numsSet[nums[leftIndex]] = 0;",
            "            windowSumm -= nums[leftIndex];",
            "            leftIndex++;",
            "        }",
            "        ",
            "        numsSet[num] = 1;",
            "        windowSumm += num;",
            "            ",
            "        if (maxSum < windowSumm){",
            "            maxSum = windowSumm;",
            "        }",
            "    }",
            "    ",
            "    return maxSum;",
            "}"
        ],
        "description": "Code snippet for arrMaximumUniqueSubarray statement"
    },
    "strHalvesAreAlike": {
        "prefix": "strHalvesAreAlike",
        "body": [
            "bool isVowel(char chr){",
            "    switch(chr){",
            "        case 'a':",
            "        case 'e':",
            "        case 'i':",
            "        case 'o':",
            "        case 'u':",
            "        case 'A':",
            "        case 'E':",
            "        case 'I':",
            "        case 'O':",
            "        case 'U':",
            "            return true;",
            "    }",
            "    ",
            "    return false;",
            "}",
            "",
            "// Counting",
            "// Runtime: O(n)",
            "// Space: O(1)",
            "bool halvesAreAlike(char * s){",
            "    int lenS = strlen(s);",
            "    int halfVowels = 0;",
            "    int currVowels = 0;",
            "    ",
            "    for (int i = 0; i < lenS; i++){",
            "        if (isVowel(s[i])){",
            "            currVowels++;",
            "        }",
            "        ",
            "        if (2 * (i + 1) == lenS){",
            "            halfVowels = currVowels;",
            "        }",
            "    }",
            "    ",
            "    return 2 * halfVowels == currVowels;",
            "}"
        ],
        "description": "Code snippet for strHalvesAreAlike statement"
    },
    "strHalvesAreAlike": {
        "prefix": "字符串前半部分和后半部分是否包含相同数量的元素",
        "body": [
            "bool isVowel(char chr){",
            "    switch(chr){",
            "        case 'a':",
            "        case 'e':",
            "        case 'i':",
            "        case 'o':",
            "        case 'u':",
            "        case 'A':",
            "        case 'E':",
            "        case 'I':",
            "        case 'O':",
            "        case 'U':",
            "            return true;",
            "    }",
            "    ",
            "    return false;",
            "}",
            "",
            "// Counting",
            "// Runtime: O(n)",
            "// Space: O(1)",
            "bool halvesAreAlike(char * s){",
            "    int lenS = strlen(s);",
            "    int halfVowels = 0;",
            "    int currVowels = 0;",
            "    ",
            "    for (int i = 0; i < lenS; i++){",
            "        if (isVowel(s[i])){",
            "            currVowels++;",
            "        }",
            "        ",
            "        if (2 * (i + 1) == lenS){",
            "            halfVowels = currVowels;",
            "        }",
            "    }",
            "    ",
            "    return 2 * halfVowels == currVowels;",
            "}"
        ],
        "description": "Code snippet for strHalvesAreAlike statement"
    },
    "bSTIterator": {
        "prefix": "bSTIterator",
        "body": [
            "#include <limits.h>",
            "//O(1)",
            "typedef struct",
            "{",
            "    int *values;",
            "    int CurrentIndex;",
            "    int NumberOfNodes;",
            "} BSTIterator;",
            "",
            "void TraverseAndAssign(struct TreeNode *root, BSTIterator *obj)",
            "{",
            "    if (!root)",
            "        return;",
            "    if (root->left)",
            "        TraverseAndAssign(root->left, obj);",
            "    obj->values[obj->CurrentIndex] = root->val;",
            "    obj->CurrentIndex++;",
            "    if (root->right)",
            "        TraverseAndAssign(root->right, obj);",
            "}",
            "",
            "int TotalNodes(struct TreeNode *root)",
            "{",
            "    if (!root)",
            "        return 0;",
            "    int nodes_left = TotalNodes(root->left);",
            "    int nodes_right = TotalNodes(root->right);",
            "    return nodes_left + nodes_right + 1;",
            "}",
            "",
            "BSTIterator *bSTIteratorCreate(struct TreeNode *root)",
            "{",
            "    int n = TotalNodes(root);",
            "    int size = n + 1;",
            "    printf(%d, size);",
            "    BSTIterator *obj = (BSTIterator *)malloc(sizeof(BSTIterator));",
            "    obj->values = (int *)calloc(size, sizeof(int));",
            "    obj->CurrentIndex = 0;",
            "    obj->NumberOfNodes = n;",
            "    obj->values[size - 1] = INT_MAX;",
            "    TraverseAndAssign(root, obj);",
            "    obj->CurrentIndex = 0;",
            "    return obj;",
            "}",
            "",
            "/** @return the next smallest number */",
            "int bSTIteratorNext(BSTIterator *obj)",
            "{",
            "    int NextValue = obj->values[obj->CurrentIndex];",
            "    obj->CurrentIndex++;",
            "    return NextValue;",
            "}",
            "",
            "/** @return whether we have a next smallest number */",
            "bool bSTIteratorHasNext(BSTIterator *obj)",
            "{",
            "    if (!obj->NumberOfNodes)",
            "    {",
            "        return false;",
            "    }",
            "    printf();",
            "    return (obj->values[obj->CurrentIndex] == INT_MAX) ? false : true;",
            "}",
            "",
            "void bSTIteratorFree(BSTIterator *obj)",
            "{",
            "    free(obj->values);",
            "    free(obj);",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "bSTIteratorCn": {
        "prefix": "二叉搜索树迭代升序遍历",
        "body": [
            "#include <limits.h>",
            "//O(1)",
            "typedef struct",
            "{",
            "    int *values;",
            "    int CurrentIndex;",
            "    int NumberOfNodes;",
            "} BSTIterator;",
            "",
            "void TraverseAndAssign(struct TreeNode *root, BSTIterator *obj)",
            "{",
            "    if (!root)",
            "        return;",
            "    if (root->left)",
            "        TraverseAndAssign(root->left, obj);",
            "    obj->values[obj->CurrentIndex] = root->val;",
            "    obj->CurrentIndex++;",
            "    if (root->right)",
            "        TraverseAndAssign(root->right, obj);",
            "}",
            "",
            "int TotalNodes(struct TreeNode *root)",
            "{",
            "    if (!root)",
            "        return 0;",
            "    int nodes_left = TotalNodes(root->left);",
            "    int nodes_right = TotalNodes(root->right);",
            "    return nodes_left + nodes_right + 1;",
            "}",
            "",
            "BSTIterator *bSTIteratorCreate(struct TreeNode *root)",
            "{",
            "    int n = TotalNodes(root);",
            "    int size = n + 1;",
            "    printf(%d, size);",
            "    BSTIterator *obj = (BSTIterator *)malloc(sizeof(BSTIterator));",
            "    obj->values = (int *)calloc(size, sizeof(int));",
            "    obj->CurrentIndex = 0;",
            "    obj->NumberOfNodes = n;",
            "    obj->values[size - 1] = INT_MAX;",
            "    TraverseAndAssign(root, obj);",
            "    obj->CurrentIndex = 0;",
            "    return obj;",
            "}",
            "",
            "/** @return the next smallest number */",
            "int bSTIteratorNext(BSTIterator *obj)",
            "{",
            "    int NextValue = obj->values[obj->CurrentIndex];",
            "    obj->CurrentIndex++;",
            "    return NextValue;",
            "}",
            "",
            "/** @return whether we have a next smallest number */",
            "bool bSTIteratorHasNext(BSTIterator *obj)",
            "{",
            "    if (!obj->NumberOfNodes)",
            "    {",
            "        return false;",
            "    }",
            "    printf();",
            "    return (obj->values[obj->CurrentIndex] == INT_MAX) ? false : true;",
            "}",
            "",
            "void bSTIteratorFree(BSTIterator *obj)",
            "{",
            "    free(obj->values);",
            "    free(obj);",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "algoMaxIceCream": {
        "prefix": "algoMaxIceCream",
        "body": [
            "int compare(const void* i, const void* j)",
            "{",
            "    return *((int*)i) - *((int*)j);",
            "}",
            "",
            "// Greedy + sorting",
            "// Runtime: O(n*log(n))",
            "// Space: O(1)",
            "int maxIceCream(int* costs, int costsSize, int coins){",
            "    qsort(costs, costsSize, sizeof(int), compare);",
            "",
            "    int result = 0;",
            "    int leftCoins = coins;",
            "    for (int i = 0; i < costsSize; i++){",
            "        if (costs[i] > leftCoins){",
            "            break;",
            "        }",
            "",
            "        leftCoins -= costs[i];",
            "        result++;",
            "    }",
            "",
            "    return result;",
            "}"
        ],
        "description": "The idea behind this greedy algorithm is to buy the cheapest ice cream possible to maximize the quantity purchased."
    },
    "algoMaxIceCream": {
        "prefix": "算法贪心算法",
        "body": [
            "//这个贪心算法的思路是尽可能购买最便宜的冰淇淋，以最大化购买的数量。""int compare(const void* i, const void* j)",
            "{",
            "    return *((int*)i) - *((int*)j);",
            "}",
            "",
            "// Greedy + sorting",
            "// Runtime: O(n*log(n))",
            "// Space: O(1)",
            "int maxIceCream(int* costs, int costsSize, int coins){",
            "    qsort(costs, costsSize, sizeof(int), compare);",
            "",
            "    int result = 0;",
            "    int leftCoins = coins;",
            "    for (int i = 0; i < costsSize; i++){",
            "        if (costs[i] > leftCoins){",
            "            break;",
            "        }",
            "",
            "        leftCoins -= costs[i];",
            "        result++;",
            "    }",
            "",
            "    return result;",
            "}"
        ],
        "description": "The idea behind this greedy algorithm is to buy the cheapest ice cream possible to maximize the quantity purchased."
    },
    "arrContainsDuplicate": {
        "prefix": "arrContainsDuplicate",
        "body": [
            "int numcmp(const void *a, const void *b) { return *(int *)a - *(int *)b; }",
            "//O(n * log(n))",
            "bool containsDuplicate(int *nums, int numsSize)",
            "{",
            "    int i;",
            "    qsort(nums, numsSize, sizeof(int), numcmp);",
            "    for (i = 0; i < numsSize - 1; i++)",
            "    {",
            "        if (nums[i] == nums[i + 1])",
            "            return 1;",
            "    }",
            "    return 0;",
            "}"
        ],
        "description": "Code snippet for arrContainsDuplicate statement"
    },
    "arrContainsDuplicateCn": {
        "prefix": "数组是否包含重复元素",
        "body": [
            "int numcmp(const void *a, const void *b) { return *(int *)a - *(int *)b; }",
            "//O(n * log(n))",
            "bool containsDuplicate(int *nums, int numsSize)",
            "{",
            "    int i;",
            "    qsort(nums, numsSize, sizeof(int), numcmp);",
            "    for (i = 0; i < numsSize - 1; i++)",
            "    {",
            "        if (nums[i] == nums[i + 1])",
            "            return 1;",
            "    }",
            "    return 0;",
            "}"
        ],
        "description": "Code snippet for arrContainsDuplicate statement"
    },
    "algoMaximumBags": {
        "prefix": "algoMaximumBags",
        "body": [
            "int compare(const int* i, const int* j)",
            "{",
            "    return *i - *j;",
            "}",
            "//The goal of this code is to calculate, given a set of backpack capacities (capacity) and a set of rock masses (rocks), the maximum number of bags of rocks that can be loaded to satisfy the capacity limit of each backpack.",
            "// Sorting.",
            "// Runtime: O(n*log(n))",
            "// Space: O(n)",
            "int maximumBags(int* capacity, int capacitySize, int* rocks, int rocksSize, int additionalRocks) {",
            "    int* capacityLeft = malloc(capacitySize * sizeof(int));",
            "    for (int i = 0; i < capacitySize; i++) {",
            "        capacityLeft[i] = capacity[i] - rocks[i];",
            "    }",
            "",
            "    qsort(capacityLeft, capacitySize, sizeof (int), (int(*) (const void*, const void*)) compare);",
            "    ",
            "    int bags = 0;",
            "    for (int i = 0; i < capacitySize; i++) {",
            "        if (additionalRocks < capacityLeft[i]){",
            "            break;",
            "        }",
            "",
            "        additionalRocks -= capacityLeft[i];",
            "        bags++;",
            "    }",
            "",
            "    free(capacityLeft);",
            "    return bags;",
            "}"
        ],
        "description": "Code snippet for algoMaximumBags statement"
    },
    "algoMaximumBagsCn": {
        "prefix": "算法背包的容量限制",
        "body": [
            "int compare(const int* i, const int* j)",
            "{",
            "    return *i - *j;",
            "}",
            "//这段代码的目标是计算在给定一组背包容量（capacity）和一组岩石质量（rocks）的情况下，最多可以装多少袋岩石，以满足每个背包的容量限制。",
            "// Sorting.",
            "// Runtime: O(n*log(n))",
            "// Space: O(n)",
            "int maximumBags(int* capacity, int capacitySize, int* rocks, int rocksSize, int additionalRocks) {",
            "    int* capacityLeft = malloc(capacitySize * sizeof(int));",
            "    for (int i = 0; i < capacitySize; i++) {",
            "        capacityLeft[i] = capacity[i] - rocks[i];",
            "    }",
            "",
            "    qsort(capacityLeft, capacitySize, sizeof (int), (int(*) (const void*, const void*)) compare);",
            "    ",
            "    int bags = 0;",
            "    for (int i = 0; i < capacitySize; i++) {",
            "        if (additionalRocks < capacityLeft[i]){",
            "            break;",
            "        }",
            "",
            "        additionalRocks -= capacityLeft[i];",
            "        bags++;",
            "    }",
            "",
            "    free(capacityLeft);",
            "    return bags;",
            "}"
        ],
        "description": "Code snippet for algoMaximumBags statement"
    },
    "algominPathCost": {
        "prefix": "algominPathCost",
        "body": [
            "#define min(x,y)(((x)<(y))?(x):(y))",
            "//The goal of this code is to calculate the minimum path cost from the upper left corner to the lower right corner in a grid. Among them, the grid contains different movement costs, and each grid has a specific cost.",
            "// DP up -> down. We are going down from gridline to gridline",
            "// and collect the minumum cost path.",
            "// Runtime : O(gridSize*gridColSize*gridColSize)",
            "// Space: O(gridColSize)",
            "int minPathCost(int** grid, int gridSize, int* gridColSize, int** moveCost, int moveCostSize, int* moveCostColSize){",
            "    int* dp = (int*)calloc(gridColSize[0], sizeof(int));",
            "    int* newDp = (int*)calloc(gridColSize[0], sizeof(int));",
            "    ",
            "    for(int i = 0; i < gridSize - 1; i++){",
            "        int currGridColSize = gridColSize[i];",
            "        for(int j = 0; j < currGridColSize; j++){",
            "            newDp[j] = -1;",
            "        }",
            "        ",
            "        for(int j = 0; j < currGridColSize; j++){",
            "            int currGridItem = grid[i][j];",
            "            for(int z = 0; z < currGridColSize; z++){",
            "                int currMoveCost = dp[j] + moveCost[currGridItem][z] + currGridItem;",
            "                ",
            "                newDp[z] = (newDp[z] == -1) ? currMoveCost : min(newDp[z], currMoveCost);",
            "            }",
            "        }",
            "        ",
            "        for(int j = 0; j < currGridColSize; j++){",
            "            dp[j] = newDp[j];",
            "        }",
            "    }",
            "    ",
            "    // Find minimum value.",
            "    int minValue = dp[0] + grid[gridSize - 1][0];",
            "    for(int j = 1; j < gridColSize[0]; j++){",
            "        minValue = min(minValue, dp[j] + grid[gridSize - 1][j]);",
            "    }",
            "    ",
            "    // free resources",
            "    free(dp);",
            "    free(newDp);",
            "    ",
            "    return minValue;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "algominPathCostcN": {
        "prefix": "算法最短路径成本",
        "body": [
            "#define min(x,y)(((x)<(y))?(x):(y))",
            "//The goal of this code is to calculate the minimum path cost from the upper left corner to the lower right corner in a grid. Among them, the grid contains different movement costs, and each grid has a specific cost.",
            "// DP up -> down. We are going down from gridline to gridline",
            "// and collect the minumum cost path.",
            "// Runtime : O(gridSize*gridColSize*gridColSize)",
            "// Space: O(gridColSize)",
            "int minPathCost(int** grid, int gridSize, int* gridColSize, int** moveCost, int moveCostSize, int* moveCostColSize){",
            "    int* dp = (int*)calloc(gridColSize[0], sizeof(int));",
            "    int* newDp = (int*)calloc(gridColSize[0], sizeof(int));",
            "    ",
            "    for(int i = 0; i < gridSize - 1; i++){",
            "        int currGridColSize = gridColSize[i];",
            "        for(int j = 0; j < currGridColSize; j++){",
            "            newDp[j] = -1;",
            "        }",
            "        ",
            "        for(int j = 0; j < currGridColSize; j++){",
            "            int currGridItem = grid[i][j];",
            "            for(int z = 0; z < currGridColSize; z++){",
            "                int currMoveCost = dp[j] + moveCost[currGridItem][z] + currGridItem;",
            "                ",
            "                newDp[z] = (newDp[z] == -1) ? currMoveCost : min(newDp[z], currMoveCost);",
            "            }",
            "        }",
            "        ",
            "        for(int j = 0; j < currGridColSize; j++){",
            "            dp[j] = newDp[j];",
            "        }",
            "    }",
            "    ",
            "    // Find minimum value.",
            "    int minValue = dp[0] + grid[gridSize - 1][0];",
            "    for(int j = 1; j < gridColSize[0]; j++){",
            "        minValue = min(minValue, dp[j] + grid[gridSize - 1][j]);",
            "    }",
            "    ",
            "    // free resources",
            "    free(dp);",
            "    free(newDp);",
            "    ",
            "    return minValue;",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "isPowerOfTwo": {
        "prefix": "algoisPowerOfTwo",
        "body": [
            "bool isPowerOfTwo(int n){",
            "    return (n > 0) && ((n & (n - 1)) == 0);",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "isPowerOfTwocn": {
        "prefix": "算法是否是2的幂",
        "body": [
            "bool isPowerOfTwo(int n){",
            "    return (n > 0) && ((n & (n - 1)) == 0);",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "isAnagram": {
        "prefix": "isAnagram",
        "body": [
            "This code checks whether two strings s and t are anagrams. An anagram is when two strings contain the same characters, just in a different order.",
            "bool isAnagram(char *s, char *t)",
            "{",
            "    int n = strlen(s);",
            "    int m = strlen(t);",
            "",
            "    int cnt_s[1000], cnt_t[1000];",
            "    for (int c = 97; c < 97 + 26; c++) cnt_s[c] = cnt_t[c] = 0;",
            "",
            "    for (int i = 0; i < n; i++) cnt_s[s[i]]++;",
            "",
            "    for (int i = 0; i < m; i++) cnt_t[t[i]]++;",
            "",
            "    for (int c = 97; c < 97 + 26; c++)",
            "        if (cnt_s[c] != cnt_t[c])",
            "            return false;",
            "",
            "    return true;",
            "}"
        ],
        "description": "Code snippet for isAnagram statement"
    },
    "isAnagramCn": {
        "prefix": "算法字母异位词",
        "body": [
            "This code checks whether two strings s and t are anagrams. An anagram is when two strings contain the same characters, just in a different order.",
            "bool isAnagram(char *s, char *t)",
            "{",
            "    int n = strlen(s);",
            "    int m = strlen(t);",
            "",
            "    int cnt_s[1000], cnt_t[1000];",
            "    for (int c = 97; c < 97 + 26; c++) cnt_s[c] = cnt_t[c] = 0;",
            "",
            "    for (int i = 0; i < n; i++) cnt_s[s[i]]++;",
            "",
            "    for (int i = 0; i < m; i++) cnt_t[t[i]]++;",
            "",
            "    for (int c = 97; c < 97 + 26; c++)",
            "        if (cnt_s[c] != cnt_t[c])",
            "            return false;",
            "",
            "    return true;",
            "}"
        ],
        "description": "Code snippet for isAnagram statement"
    },
    "arrRemoveDuplicates": {
        "prefix": "arrRemoveDuplicates",
        "body": [
            "int removeDuplicates(int *nums, int numsSize)",
            "{",
            "    int count = 0, i;",
            "    for (i = 1; i < numsSize; i++)",
            "    {",
            "        if (nums[i] == nums[i - 1])",
            "            count++;",
            "        else",
            "            nums[i - count] = nums[i];",
            "    }",
            "    return numsSize - count;",
            "}"
        ],
        "description": "Code snippet for arrRemoveDuplicates statement"
    },
    "arrRemoveDuplicatescn": {
        "prefix": "数组删除重复元素",
        "body": [
            "int removeDuplicates(int *nums, int numsSize)",
            "{",
            "    int count = 0, i;",
            "    for (i = 1; i < numsSize; i++)",
            "    {",
            "        if (nums[i] == nums[i - 1])",
            "            count++;",
            "        else",
            "            nums[i - count] = nums[i];",
            "    }",
            "    return numsSize - count;",
            "}"
        ],
        "description": "Code snippet for arrRemoveDuplicates statement"
    },
    "removeElement": {
        "prefix": "arrRemoveElement",
        "body": [
            "int removeElement(int *nums, int numsSize, int val)",
            "{",
            "    int i, start = 0;",
            "    for (i = 0; i < numsSize; i++)",
            "    {",
            "        if (nums[i] != val)",
            "            nums[start++] = nums[i];",
            "    }",
            "    return start;",
            "}"
        ],
        "description": "Code snippet for arrRemoveElement statement"
    },
    "removeElement": {
        "prefix": "数组删除元素",
        "body": [
            "int removeElement(int *nums, int numsSize, int val)",
            "{",
            "    int i, start = 0;",
            "    for (i = 0; i < numsSize; i++)",
            "    {",
            "        if (nums[i] != val)",
            "            nums[start++] = nums[i];",
            "    }",
            "    return start;",
            "}"
        ],
        "description": "Code snippet for arrRemoveElement statement"
    },
    "strFindSubStr": {
        "prefix": "strFindSubStr",
        "body": [
            "*",
            " * brute force approach",
            " * time complexity: O(mn)",
            " */",
            "int strStr(char *haystack, char *needle)",
            "{",
            "    int i = 0;",
            "    int j = 0;",
            "    int k = 0;",
            "    int hlen = 0;",
            "    int nlen = 0;",
            "",
            "    if (needle == NULL || *needle == 0)",
            "        return 0;",
            "",
            "    if (haystack == NULL || *haystack == 0)",
            "        return -1;",
            "",
            "    hlen = strlen(haystack);",
            "    nlen = strlen(needle);",
            "",
            "    if (hlen < nlen)",
            "        return -1;",
            "",
            "    for (i = 0; i <= hlen - nlen; i++)",
            "    {",
            "        j = 0;",
            "        if (haystack[i] != needle[j++])",
            "            continue;",
            "",
            "        k = i + 1;",
            "        for (; j < nlen; j++)",
            "        {",
            "            if (haystack[k] != needle[j])",
            "            {",
            "                break;",
            "            }",
            "            else",
            "                k++;",
            "        }",
            "        if (j == nlen)",
            "            return i;",
            "    }",
            "    return -1;",
            "}",
            "",
            "/* ----------------------------------------------------------------------------------------",
            " */",
            "",
            "/*",
            " * KMP algorithm",
            " * time complexity: O(m + n)",
            " */",
            "",
            "/* fills overlap with longest proper prefix which is also suffix for each index",
            " * in needle */",
            "void fill_overlap(char *needle, int len_needle, int *overlap)",
            "{",
            "    int len = 0;",
            "    int i = 0;",
            "",
            "    overlap[0] = 0;",
            "",
            "    for (i = 1; i < len_needle;)",
            "    {",
            "        if (needle[i] == needle[len])",
            "        {",
            "            len++;",
            "            overlap[i++] = len;",
            "        }",
            "        else",
            "        {",
            "            if (len)",
            "                len = overlap[len - 1];",
            "            else",
            "                overlap[i++] = 0;",
            "        }",
            "    }",
            "}",
            "",
            "int strStr(char *haystack, char *needle)",
            "{",
            "    int i = 0; /* index for haystack */",
            "    int j = 0; /* index for needle */",
            "",
            "    int len_needle = strlen(needle);",
            "    int len_haystack = strlen(haystack);",
            "",
            "    if (!len_needle)",
            "        return 0;",
            "",
            "    int overlap[len_needle];",
            "",
            "    fill_overlap(needle, len_needle, overlap);",
            "",
            "    while (i < len_haystack)",
            "    {",
            "        if (needle[j] == haystack[i])",
            "        {",
            "            i++;",
            "            j++;",
            "        }",
            "",
            "        if (j == len_needle)",
            "        {",
            "            return (i - j);",
            "        }",
            "        else if (i < len_haystack && needle[j] != haystack[i])",
            "        {",
            "            if (j != 0)",
            "                j = overlap[j - 1];",
            "            else",
            "                i = i + 1;",
            "        }",
            "    }",
            "    return -1;",
            "}"
        ],
        "description": "Code snippet for strFindSubStr statement"
    },
    "strFindSubStr": {
        "prefix": "字符串查找字串",
        "body": [
            "*",
            " * brute force approach",
            " * time complexity: O(mn)",
            " */",
            "int strStr(char *haystack, char *needle)",
            "{",
            "    int i = 0;",
            "    int j = 0;",
            "    int k = 0;",
            "    int hlen = 0;",
            "    int nlen = 0;",
            "",
            "    if (needle == NULL || *needle == 0)",
            "        return 0;",
            "",
            "    if (haystack == NULL || *haystack == 0)",
            "        return -1;",
            "",
            "    hlen = strlen(haystack);",
            "    nlen = strlen(needle);",
            "",
            "    if (hlen < nlen)",
            "        return -1;",
            "",
            "    for (i = 0; i <= hlen - nlen; i++)",
            "    {",
            "        j = 0;",
            "        if (haystack[i] != needle[j++])",
            "            continue;",
            "",
            "        k = i + 1;",
            "        for (; j < nlen; j++)",
            "        {",
            "            if (haystack[k] != needle[j])",
            "            {",
            "                break;",
            "            }",
            "            else",
            "                k++;",
            "        }",
            "        if (j == nlen)",
            "            return i;",
            "    }",
            "    return -1;",
            "}",
            "",
            "/* ----------------------------------------------------------------------------------------",
            " */",
            "",
            "/*",
            " * KMP algorithm",
            " * time complexity: O(m + n)",
            " */",
            "",
            "/* fills overlap with longest proper prefix which is also suffix for each index",
            " * in needle */",
            "void fill_overlap(char *needle, int len_needle, int *overlap)",
            "{",
            "    int len = 0;",
            "    int i = 0;",
            "",
            "    overlap[0] = 0;",
            "",
            "    for (i = 1; i < len_needle;)",
            "    {",
            "        if (needle[i] == needle[len])",
            "        {",
            "            len++;",
            "            overlap[i++] = len;",
            "        }",
            "        else",
            "        {",
            "            if (len)",
            "                len = overlap[len - 1];",
            "            else",
            "                overlap[i++] = 0;",
            "        }",
            "    }",
            "}",
            "",
            "int strStr(char *haystack, char *needle)",
            "{",
            "    int i = 0; /* index for haystack */",
            "    int j = 0; /* index for needle */",
            "",
            "    int len_needle = strlen(needle);",
            "    int len_haystack = strlen(haystack);",
            "",
            "    if (!len_needle)",
            "        return 0;",
            "",
            "    int overlap[len_needle];",
            "",
            "    fill_overlap(needle, len_needle, overlap);",
            "",
            "    while (i < len_haystack)",
            "    {",
            "        if (needle[j] == haystack[i])",
            "        {",
            "            i++;",
            "            j++;",
            "        }",
            "",
            "        if (j == len_needle)",
            "        {",
            "            return (i - j);",
            "        }",
            "        else if (i < len_haystack && needle[j] != haystack[i])",
            "        {",
            "            if (j != 0)",
            "                j = overlap[j - 1];",
            "            else",
            "                i = i + 1;",
            "        }",
            "    }",
            "    return -1;",
            "}"
        ],
        "description": "Code snippet for strFindSubStr statement"
    },
    "compareTimeStrings": {
        "prefix": "compareTimeStrings",
        "body": [
            "#include <time.h>",
            "int compareTimeStrings(const char *timeStr1, const char *timeStr2) {",
            "    struct tm tm1, tm2;",
            "    time_t time1, time2;",
            "",
            "    // 使用strptime解析时间字符串",
            "    if (strptime(timeStr1, \"%Y-%m-%d %H:%M:%S\", &tm1) == NULL) {",
            "        return -1;",
            "    }",
            "",
            "    if (strptime(timeStr2, %Y-%m-%d %H:%M:%S, &tm2) == NULL) {",
            "        return -1;",
            "    }",
            "",
            "    // 将tm结构转换为time_t（秒数）",
            "    time1 = mktime(&tm1);",
            "    time2 = mktime(&tm2);",
            "",
            "    if (time1 == -1 || time2 == -1) {",
            "        return -1;",
            "    }",
            "",
            "    // 比较时间",
            "    if (time1 < time2) {",
            "        return -1;",
            "    } else if (time1 > time2) {",
            "        return 1;",
            "    } else {",
            "        return 0;",
            "    }",
            "}"
        ],
        "description": "Code snippet for compareTimeStrings statement"
    },
    "compareTimeStrings": {
        "prefix": "比较两个时间字符串",
        "body": [
            "#include <time.h>",
            "int compareTimeStrings(const char *timeStr1, const char *timeStr2) {",
            "    struct tm tm1, tm2;",
            "    time_t time1, time2;",
            "",
            "    // 使用strptime解析时间字符串",
            "    if (strptime(timeStr1, \"%Y-%m-%d %H:%M:%S\", &tm1) == NULL) {",
            "        return -1;",
            "    }",
            "",
            "    if (strptime(timeStr2, %Y-%m-%d %H:%M:%S, &tm2) == NULL) {",
            "        return -1;",
            "    }",
            "",
            "    // 将tm结构转换为time_t（秒数）",
            "    time1 = mktime(&tm1);",
            "    time2 = mktime(&tm2);",
            "",
            "    if (time1 == -1 || time2 == -1) {",
            "        return -1;",
            "    }",
            "",
            "    // 比较时间",
            "    if (time1 < time2) {",
            "        return -1;",
            "    } else if (time1 > time2) {",
            "        return 1;",
            "    } else {",
            "        return 0;",
            "    }",
            "}"
        ],
        "description": "Code snippet for compareTimeStrings statement"
    },
    "compareTimeWithCurrentTime": {
        "prefix": "compareTimeWithCurrentTime",
        "body": [
            "#include <time.h>",
            "int compareTimeWithCurrentTime(const char *timeStr1) {",
            "    struct tm tm1, tm2;",
            "    time_t currentTime;",
            "    ",
            "    // 获取当前时间",
            "    time(&currentTime);",
            "    ",
            "    // 将当前时间转换为 tm 结构",
            "    localtime_r(&currentTime, &tm2);",
            "    ",
            "    // 将 timeStr1 转换为 tm 结构",
            "    if (strptime(timeStr1, \"%Y-%m-%d %H:%M:%S\", &tm1) == NULL) {",
            "        return -1;  // 返回错误代码",
            "    }",
            "",
            "    // 将 tm 结构转换为 time_t 类型",
            "    time_t time1 = mktime(&tm1);",
            "    time_t time2 = mktime(&tm2);",
            "",
            "    if (time1 < time2) {",
            "        return -1;  // timeStr1 早于当前时间",
            "    } else if (time1 > time2) {",
            "        return 1;   // timeStr1 晚于当前时间",
            "    } else {",
            "        return 0;   // timeStr1 与当前时间相等",
            "    }",
            "}"
        ],
        "description": "Code snippet for compareTimeWithCurrentTime statement"
    },
    "compareTimeWithCurrentTime": {
        "prefix": "时间字符串和当前时间作比较",
        "body": [
            "#include <time.h>",
            "int compareTimeWithCurrentTime(const char *timeStr1) {",
            "    struct tm tm1, tm2;",
            "    time_t currentTime;",
            "    ",
            "    // 获取当前时间",
            "    time(&currentTime);",
            "    ",
            "    // 将当前时间转换为 tm 结构",
            "    localtime_r(&currentTime, &tm2);",
            "    ",
            "    // 将 timeStr1 转换为 tm 结构",
            "    if (strptime(timeStr1, \"%Y-%m-%d %H:%M:%S\", &tm1) == NULL) {",
            "        return -1;  // 返回错误代码",
            "    }",
            "",
            "    // 将 tm 结构转换为 time_t 类型",
            "    time_t time1 = mktime(&tm1);",
            "    time_t time2 = mktime(&tm2);",
            "",
            "    if (time1 < time2) {",
            "        return -1;  // timeStr1 早于当前时间",
            "    } else if (time1 > time2) {",
            "        return 1;   // timeStr1 晚于当前时间",
            "    } else {",
            "        return 0;   // timeStr1 与当前时间相等",
            "    }",
            "}"
        ],
        "description": "Code snippet for compareTimeWithCurrentTime statement"
    },
    "findStringInArray": {
        "prefix": "strfindStringInArray",
        "body": [
            "char *stringArray[3] = {\"abc\",\"abc\"\"abc\"};",
            "char *target = {\"abc\"};",
            "int findStringInArray(const char *target, const char *stringArray[], int arraySize) {",
            "    for (int i = 0; i < arraySize; i++) {",
            "        if (strcmp(target, stringArray[i]) == 0) {",
            "            return i;  // 返回匹配到的位置",
            "        }",
            "    }",
            "    return -1;  // 未找到匹配项",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "findStringInArray": {
        "prefix": "字符串数组中匹配字符串",
        "body": [
            "char *stringArray[3] = {\"abc\",\"abc\"\"abc\"};",
            "char *target = {\"abc\"};",
            "int findStringInArray(const char *target, const char *stringArray[], int arraySize) {",
            "    for (int i = 0; i < arraySize; i++) {",
            "        if (strcmp(target, stringArray[i]) == 0) {",
            "            return i;  // 返回匹配到的位置",
            "        }",
            "    }",
            "    return -1;  // 未找到匹配项",
            "}"
        ],
        "description": "Code snippet for switch statement"
    },
    "removeSpaces": {
        "prefix": "strremoveSpaces",
        "body": [
            "void removeSpaces(char *str) {",
            "    int len = strlen(str);",
            "    int i, j = 0;",
            "",
            "    for (i = 0; i < len; i++) {",
            "        if (str[i] != ' ') {",
            "            str[j] = str[i];",
            "            j++;",
            "        }",
            "    }",
            "    str[j] = '\\0'; // 在新字符串的末尾添加 null 终止符，以确保字符串正确终止",
            "}"
        ],
        "description": "Code snippet for strremoveSpaces statement"
    },
    "removeSpaces": {
        "prefix": "字符串移除空格",
        "body": [
            "void removeSpaces(char *str) {",
            "    int len = strlen(str);",
            "    int i, j = 0;",
            "",
            "    for (i = 0; i < len; i++) {",
            "        if (str[i] != ' ') {",
            "            str[j] = str[i];",
            "            j++;",
            "        }",
            "    }",
            "    str[j] = '\\0'; // 在新字符串的末尾添加 null 终止符，以确保字符串正确终止",
            "}"
        ],
        "description": "Code snippet for strremoveSpaces statement"
    },
    "switch": {
        "prefix": "switch",
        "body": [
            "swi"
        ],
        "description": "Code snippet for switch statement"
    },
}